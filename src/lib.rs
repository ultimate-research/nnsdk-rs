#![no_std]
#![feature(repr_simd)]
/* automatically generated by rust-bindgen */

#[cfg(not(feature = "rustc-dep-of-std"))]
extern crate alloc;

pub mod extensions;

#[doc(inline)]
pub use root::nn::*;

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[doc(hidden)]
pub mod root {
    #[repr(C)]
    #[derive(Default)]
    pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
    impl<T> __IncompleteArrayField<T> {
        #[inline]
        pub const fn new() -> Self {
            __IncompleteArrayField(::core::marker::PhantomData, [])
        }
        #[inline]
        pub fn as_ptr(&self) -> *const T {
            self as *const _ as *const T
        }
        #[inline]
        pub fn as_mut_ptr(&mut self) -> *mut T {
            self as *mut _ as *mut T
        }
        #[inline]
        pub unsafe fn as_slice(&self, len: usize) -> &[T] {
            ::core::slice::from_raw_parts(self.as_ptr(), len)
        }
        #[inline]
        pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
            ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
        }
    }
    impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            fmt.write_str("__IncompleteArrayField")
        }
    }
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub const fn new() -> Self {
            __BindgenUnionField(::core::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::core::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::core::mem::transmute(self)
        }
    }
    impl<T> ::core::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
    #[allow(unused_imports)]
    use self::super::root;
    pub type __u_char = libc::c_uchar;
    pub type __u_short = libc::c_ushort;
    pub type __u_int = libc::c_uint;
    pub type __u_long = libc::c_ulong;
    pub type __int8_t = libc::c_schar;
    pub type __uint8_t = libc::c_uchar;
    pub type __int16_t = libc::c_short;
    pub type __uint16_t = libc::c_ushort;
    pub type __int32_t = libc::c_int;
    pub type __uint32_t = libc::c_uint;
    pub type __int64_t = libc::c_long;
    pub type __uint64_t = libc::c_ulong;
    pub type __int_least8_t = root::__int8_t;
    pub type __uint_least8_t = root::__uint8_t;
    pub type __int_least16_t = root::__int16_t;
    pub type __uint_least16_t = root::__uint16_t;
    pub type __int_least32_t = root::__int32_t;
    pub type __uint_least32_t = root::__uint32_t;
    pub type __int_least64_t = root::__int64_t;
    pub type __uint_least64_t = root::__uint64_t;
    pub type __quad_t = libc::c_long;
    pub type __u_quad_t = libc::c_ulong;
    pub type __intmax_t = libc::c_long;
    pub type __uintmax_t = libc::c_ulong;
    pub type __dev_t = libc::c_ulong;
    pub type __uid_t = libc::c_uint;
    pub type __gid_t = libc::c_uint;
    pub type __ino_t = libc::c_ulong;
    pub type __ino64_t = libc::c_ulong;
    pub type __mode_t = libc::c_uint;
    pub type __nlink_t = libc::c_ulong;
    pub type __off_t = libc::c_long;
    pub type __off64_t = libc::c_long;
    pub type __pid_t = libc::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __fsid_t {
        pub __val: [libc::c_int; 2usize],
    }
    #[test]
    fn bindgen_test_layout___fsid_t() {
        assert_eq!(
            ::core::mem::size_of::<__fsid_t>(),
            8usize,
            concat!("Size of: ", stringify!(__fsid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<__fsid_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__fsid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    pub type __clock_t = libc::c_long;
    pub type __rlim_t = libc::c_ulong;
    pub type __rlim64_t = libc::c_ulong;
    pub type __id_t = libc::c_uint;
    pub type __time_t = libc::c_long;
    pub type __useconds_t = libc::c_uint;
    pub type __suseconds_t = libc::c_long;
    pub type __daddr_t = libc::c_int;
    pub type __key_t = libc::c_int;
    pub type __clockid_t = libc::c_int;
    pub type __timer_t = *mut libc::c_void;
    pub type __blksize_t = libc::c_long;
    pub type __blkcnt_t = libc::c_long;
    pub type __blkcnt64_t = libc::c_long;
    pub type __fsblkcnt_t = libc::c_ulong;
    pub type __fsblkcnt64_t = libc::c_ulong;
    pub type __fsfilcnt_t = libc::c_ulong;
    pub type __fsfilcnt64_t = libc::c_ulong;
    pub type __fsword_t = libc::c_long;
    pub type __ssize_t = libc::c_long;
    pub type __syscall_slong_t = libc::c_long;
    pub type __syscall_ulong_t = libc::c_ulong;
    pub type __loff_t = root::__off64_t;
    pub type __caddr_t = *mut libc::c_char;
    pub type __intptr_t = libc::c_long;
    pub type __socklen_t = libc::c_uint;
    pub type __sig_atomic_t = libc::c_int;
    pub type int_least8_t = root::__int_least8_t;
    pub type int_least16_t = root::__int_least16_t;
    pub type int_least32_t = root::__int_least32_t;
    pub type int_least64_t = root::__int_least64_t;
    pub type uint_least8_t = root::__uint_least8_t;
    pub type uint_least16_t = root::__uint_least16_t;
    pub type uint_least32_t = root::__uint_least32_t;
    pub type uint_least64_t = root::__uint_least64_t;
    pub type int_fast8_t = libc::c_schar;
    pub type int_fast16_t = libc::c_long;
    pub type int_fast32_t = libc::c_long;
    pub type int_fast64_t = libc::c_long;
    pub type uint_fast8_t = libc::c_uchar;
    pub type uint_fast16_t = libc::c_ulong;
    pub type uint_fast32_t = libc::c_ulong;
    pub type uint_fast64_t = libc::c_ulong;
    pub type intmax_t = root::__intmax_t;
    pub type uintmax_t = root::__uintmax_t;
    pub type size_t = libc::c_ulong;
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Copy, Clone)]
    pub struct max_align_t {
        pub __clang_max_align_nonce1: libc::c_longlong,
        pub __bindgen_padding_0: u64,
        pub __clang_max_align_nonce2: u128,
    }
    #[test]
    fn bindgen_test_layout_max_align_t() {
        assert_eq!(
            ::core::mem::size_of::<max_align_t>(),
            32usize,
            concat!("Size of: ", stringify!(max_align_t))
        );
        assert_eq!(
            ::core::mem::align_of::<max_align_t>(),
            16usize,
            concat!("Alignment of ", stringify!(max_align_t))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imaxdiv_t {
        pub quot: libc::c_long,
        pub rem: libc::c_long,
    }
    #[test]
    fn bindgen_test_layout_imaxdiv_t() {
        assert_eq!(
            ::core::mem::size_of::<imaxdiv_t>(),
            16usize,
            concat!("Size of: ", stringify!(imaxdiv_t))
        );
        assert_eq!(
            ::core::mem::align_of::<imaxdiv_t>(),
            8usize,
            concat!("Alignment of ", stringify!(imaxdiv_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(quot)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    extern "C" {
        pub fn imaxabs(__n: root::intmax_t) -> root::intmax_t;
    }
    extern "C" {
        pub fn imaxdiv(__numer: root::intmax_t, __denom: root::intmax_t) -> root::imaxdiv_t;
    }
    extern "C" {
        pub fn strtoimax(
            __nptr: *const libc::c_char,
            __endptr: *mut *mut libc::c_char,
            __base: libc::c_int,
        ) -> root::intmax_t;
    }
    extern "C" {
        pub fn strtoumax(
            __nptr: *const libc::c_char,
            __endptr: *mut *mut libc::c_char,
            __base: libc::c_int,
        ) -> root::uintmax_t;
    }
    extern "C" {
        pub fn wcstoimax(
            __nptr: *const u32,
            __endptr: *mut *mut u32,
            __base: libc::c_int,
        ) -> root::intmax_t;
    }
    extern "C" {
        pub fn wcstoumax(
            __nptr: *const u32,
            __endptr: *mut *mut u32,
            __base: libc::c_int,
        ) -> root::uintmax_t;
    }
    extern "C" {
        #[link_name = "\u{1}__cxa_demangle"]
        pub fn cxa_demangle(
            symbol_name: *const u8,
            unk1: *const u8,
            unk2: *const u8,
            result: *mut u32,
        ) -> *mut u8;
    }
    pub type s8 = i8;
    pub type s16 = i16;
    pub type s32 = i32;
    pub type s64 = i64;
    pub type s128 = root::__int128_t;
    pub type uchar = libc::c_uchar;
    pub type ulong = libc::c_ulong;
    pub type uint = u32;
    pub type Result = u32;
    pub type Handle = u32;
    pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>;
    pub const Module_Kernel: root::_bindgen_ty_1 = 1;
    pub const Module_Libnx: root::_bindgen_ty_1 = 345;
    pub const Module_HomebrewAbi: root::_bindgen_ty_1 = 346;
    pub const Module_HomebrewLoader: root::_bindgen_ty_1 = 347;
    pub const Module_LibnxNvidia: root::_bindgen_ty_1 = 348;
    pub const Module_LibnxBinder: root::_bindgen_ty_1 = 349;
    #[doc = " Module values"]
    pub type _bindgen_ty_1 = u32;
    pub const KernelError_OutOfSessions: root::_bindgen_ty_2 = 7;
    pub const KernelError_InvalidCapabilityDescriptor: root::_bindgen_ty_2 = 14;
    pub const KernelError_NotImplemented: root::_bindgen_ty_2 = 33;
    pub const KernelError_ThreadTerminating: root::_bindgen_ty_2 = 59;
    pub const KernelError_OutOfDebugEvents: root::_bindgen_ty_2 = 70;
    pub const KernelError_InvalidSize: root::_bindgen_ty_2 = 101;
    pub const KernelError_InvalidAddress: root::_bindgen_ty_2 = 102;
    pub const KernelError_ResourceExhausted: root::_bindgen_ty_2 = 103;
    pub const KernelError_OutOfMemory: root::_bindgen_ty_2 = 104;
    pub const KernelError_OutOfHandles: root::_bindgen_ty_2 = 105;
    pub const KernelError_InvalidMemoryState: root::_bindgen_ty_2 = 106;
    pub const KernelError_InvalidMemoryPermissions: root::_bindgen_ty_2 = 108;
    pub const KernelError_InvalidMemoryRange: root::_bindgen_ty_2 = 110;
    pub const KernelError_InvalidPriority: root::_bindgen_ty_2 = 112;
    pub const KernelError_InvalidCoreId: root::_bindgen_ty_2 = 113;
    pub const KernelError_InvalidHandle: root::_bindgen_ty_2 = 114;
    pub const KernelError_InvalidUserBuffer: root::_bindgen_ty_2 = 115;
    pub const KernelError_InvalidCombination: root::_bindgen_ty_2 = 116;
    pub const KernelError_TimedOut: root::_bindgen_ty_2 = 117;
    pub const KernelError_Cancelled: root::_bindgen_ty_2 = 118;
    pub const KernelError_OutOfRange: root::_bindgen_ty_2 = 119;
    pub const KernelError_InvalidEnumValue: root::_bindgen_ty_2 = 120;
    pub const KernelError_NotFound: root::_bindgen_ty_2 = 121;
    pub const KernelError_AlreadyExists: root::_bindgen_ty_2 = 122;
    pub const KernelError_ConnectionClosed: root::_bindgen_ty_2 = 123;
    pub const KernelError_UnhandledUserInterrupt: root::_bindgen_ty_2 = 124;
    pub const KernelError_InvalidState: root::_bindgen_ty_2 = 125;
    pub const KernelError_ReservedValue: root::_bindgen_ty_2 = 126;
    pub const KernelError_InvalidHwBreakpoint: root::_bindgen_ty_2 = 127;
    pub const KernelError_FatalUserException: root::_bindgen_ty_2 = 128;
    pub const KernelError_OwnedByAnotherProcess: root::_bindgen_ty_2 = 129;
    pub const KernelError_ConnectionRefused: root::_bindgen_ty_2 = 131;
    pub const KernelError_OutOfResource: root::_bindgen_ty_2 = 132;
    pub const KernelError_IpcMapFailed: root::_bindgen_ty_2 = 259;
    pub const KernelError_IpcCmdbufTooSmall: root::_bindgen_ty_2 = 260;
    pub const KernelError_NotDebugged: root::_bindgen_ty_2 = 520;
    #[doc = " Kernel error codes"]
    pub type _bindgen_ty_2 = u32;
    pub const LibnxError_BadReloc: root::_bindgen_ty_3 = 1;
    pub const LibnxError_OutOfMemory: root::_bindgen_ty_3 = 2;
    pub const LibnxError_AlreadyMapped: root::_bindgen_ty_3 = 3;
    pub const LibnxError_BadGetInfo_Stack: root::_bindgen_ty_3 = 4;
    pub const LibnxError_BadGetInfo_Heap: root::_bindgen_ty_3 = 5;
    pub const LibnxError_BadQueryMemory: root::_bindgen_ty_3 = 6;
    pub const LibnxError_AlreadyInitialized: root::_bindgen_ty_3 = 7;
    pub const LibnxError_NotInitialized: root::_bindgen_ty_3 = 8;
    pub const LibnxError_NotFound: root::_bindgen_ty_3 = 9;
    pub const LibnxError_IoError: root::_bindgen_ty_3 = 10;
    pub const LibnxError_BadInput: root::_bindgen_ty_3 = 11;
    pub const LibnxError_BadReent: root::_bindgen_ty_3 = 12;
    pub const LibnxError_BufferProducerError: root::_bindgen_ty_3 = 13;
    pub const LibnxError_HandleTooEarly: root::_bindgen_ty_3 = 14;
    pub const LibnxError_HeapAllocFailed: root::_bindgen_ty_3 = 15;
    pub const LibnxError_TooManyOverrides: root::_bindgen_ty_3 = 16;
    pub const LibnxError_ParcelError: root::_bindgen_ty_3 = 17;
    pub const LibnxError_BadGfxInit: root::_bindgen_ty_3 = 18;
    pub const LibnxError_BadGfxEventWait: root::_bindgen_ty_3 = 19;
    pub const LibnxError_BadGfxQueueBuffer: root::_bindgen_ty_3 = 20;
    pub const LibnxError_BadGfxDequeueBuffer: root::_bindgen_ty_3 = 21;
    pub const LibnxError_AppletCmdidNotFound: root::_bindgen_ty_3 = 22;
    pub const LibnxError_BadAppletReceiveMessage: root::_bindgen_ty_3 = 23;
    pub const LibnxError_BadAppletNotifyRunning: root::_bindgen_ty_3 = 24;
    pub const LibnxError_BadAppletGetCurrentFocusState: root::_bindgen_ty_3 = 25;
    pub const LibnxError_BadAppletGetOperationMode: root::_bindgen_ty_3 = 26;
    pub const LibnxError_BadAppletGetPerformanceMode: root::_bindgen_ty_3 = 27;
    pub const LibnxError_BadUsbCommsRead: root::_bindgen_ty_3 = 28;
    pub const LibnxError_BadUsbCommsWrite: root::_bindgen_ty_3 = 29;
    pub const LibnxError_InitFail_SM: root::_bindgen_ty_3 = 30;
    pub const LibnxError_InitFail_AM: root::_bindgen_ty_3 = 31;
    pub const LibnxError_InitFail_HID: root::_bindgen_ty_3 = 32;
    pub const LibnxError_InitFail_FS: root::_bindgen_ty_3 = 33;
    pub const LibnxError_BadGetInfo_Rng: root::_bindgen_ty_3 = 34;
    pub const LibnxError_JitUnavailable: root::_bindgen_ty_3 = 35;
    pub const LibnxError_WeirdKernel: root::_bindgen_ty_3 = 36;
    pub const LibnxError_IncompatSysVer: root::_bindgen_ty_3 = 37;
    pub const LibnxError_InitFail_Time: root::_bindgen_ty_3 = 38;
    pub const LibnxError_TooManyDevOpTabs: root::_bindgen_ty_3 = 39;
    pub const LibnxError_DomainMessageUnknownType: root::_bindgen_ty_3 = 40;
    pub const LibnxError_DomainMessageTooManyObjectIds: root::_bindgen_ty_3 = 41;
    pub const LibnxError_AppletFailedToInitialize: root::_bindgen_ty_3 = 42;
    pub const LibnxError_ApmFailedToInitialize: root::_bindgen_ty_3 = 43;
    pub const LibnxError_NvinfoFailedToInitialize: root::_bindgen_ty_3 = 44;
    pub const LibnxError_NvbufFailedToInitialize: root::_bindgen_ty_3 = 45;
    pub const LibnxError_LibAppletBadExit: root::_bindgen_ty_3 = 46;
    pub const LibnxError_InvalidCmifOutHeader: root::_bindgen_ty_3 = 47;
    pub const LibnxError_ShouldNotHappen: root::_bindgen_ty_3 = 48;
    #[doc = " libnx error codes"]
    pub type _bindgen_ty_3 = u32;
    pub const LibnxBinderError_Unknown: root::_bindgen_ty_4 = 1;
    pub const LibnxBinderError_NoMemory: root::_bindgen_ty_4 = 2;
    pub const LibnxBinderError_InvalidOperation: root::_bindgen_ty_4 = 3;
    pub const LibnxBinderError_BadValue: root::_bindgen_ty_4 = 4;
    pub const LibnxBinderError_BadType: root::_bindgen_ty_4 = 5;
    pub const LibnxBinderError_NameNotFound: root::_bindgen_ty_4 = 6;
    pub const LibnxBinderError_PermissionDenied: root::_bindgen_ty_4 = 7;
    pub const LibnxBinderError_NoInit: root::_bindgen_ty_4 = 8;
    pub const LibnxBinderError_AlreadyExists: root::_bindgen_ty_4 = 9;
    pub const LibnxBinderError_DeadObject: root::_bindgen_ty_4 = 10;
    pub const LibnxBinderError_FailedTransaction: root::_bindgen_ty_4 = 11;
    pub const LibnxBinderError_BadIndex: root::_bindgen_ty_4 = 12;
    pub const LibnxBinderError_NotEnoughData: root::_bindgen_ty_4 = 13;
    pub const LibnxBinderError_WouldBlock: root::_bindgen_ty_4 = 14;
    pub const LibnxBinderError_TimedOut: root::_bindgen_ty_4 = 15;
    pub const LibnxBinderError_UnknownTransaction: root::_bindgen_ty_4 = 16;
    pub const LibnxBinderError_FdsNotAllowed: root::_bindgen_ty_4 = 17;
    #[doc = " libnx binder error codes"]
    pub type _bindgen_ty_4 = u32;
    pub const LibnxNvidiaError_Unknown: root::_bindgen_ty_5 = 1;
    #[doc = "< Maps to Nvidia: 1"]
    pub const LibnxNvidiaError_NotImplemented: root::_bindgen_ty_5 = 2;
    #[doc = "< Maps to Nvidia: 2"]
    pub const LibnxNvidiaError_NotSupported: root::_bindgen_ty_5 = 3;
    #[doc = "< Maps to Nvidia: 3"]
    pub const LibnxNvidiaError_NotInitialized: root::_bindgen_ty_5 = 4;
    #[doc = "< Maps to Nvidia: 4"]
    pub const LibnxNvidiaError_BadParameter: root::_bindgen_ty_5 = 5;
    #[doc = "< Maps to Nvidia: 5"]
    pub const LibnxNvidiaError_Timeout: root::_bindgen_ty_5 = 6;
    #[doc = "< Maps to Nvidia: 6"]
    pub const LibnxNvidiaError_InsufficientMemory: root::_bindgen_ty_5 = 7;
    #[doc = "< Maps to Nvidia: 7"]
    pub const LibnxNvidiaError_ReadOnlyAttribute: root::_bindgen_ty_5 = 8;
    #[doc = "< Maps to Nvidia: 8"]
    pub const LibnxNvidiaError_InvalidState: root::_bindgen_ty_5 = 9;
    #[doc = "< Maps to Nvidia: 9"]
    pub const LibnxNvidiaError_InvalidAddress: root::_bindgen_ty_5 = 10;
    #[doc = "< Maps to Nvidia: 10"]
    pub const LibnxNvidiaError_InvalidSize: root::_bindgen_ty_5 = 11;
    #[doc = "< Maps to Nvidia: 11"]
    pub const LibnxNvidiaError_BadValue: root::_bindgen_ty_5 = 12;
    #[doc = "< Maps to Nvidia: 13"]
    pub const LibnxNvidiaError_AlreadyAllocated: root::_bindgen_ty_5 = 13;
    #[doc = "< Maps to Nvidia: 14"]
    pub const LibnxNvidiaError_Busy: root::_bindgen_ty_5 = 14;
    #[doc = "< Maps to Nvidia: 15"]
    pub const LibnxNvidiaError_ResourceError: root::_bindgen_ty_5 = 15;
    #[doc = "< Maps to Nvidia: 16"]
    pub const LibnxNvidiaError_CountMismatch: root::_bindgen_ty_5 = 16;
    #[doc = "< Maps to Nvidia: 0x1000"]
    pub const LibnxNvidiaError_SharedMemoryTooSmall: root::_bindgen_ty_5 = 17;
    #[doc = "< Maps to Nvidia: 0x30003"]
    pub const LibnxNvidiaError_FileOperationFailed: root::_bindgen_ty_5 = 18;
    #[doc = "< Maps to Nvidia: 0x3000F"]
    pub const LibnxNvidiaError_IoctlFailed: root::_bindgen_ty_5 = 19;
    #[doc = " libnx nvidia error codes"]
    pub type _bindgen_ty_5 = u32;
    pub mod nn {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type ApplicationId = u64;
        #[repr(C)]
        pub struct TimeSpan {
            pub nanoseconds: u64,
        }
        #[test]
        fn bindgen_test_layout_TimeSpan() {
            assert_eq!(
                ::core::mem::size_of::<TimeSpan>(),
                8usize,
                concat!("Size of: ", stringify!(TimeSpan))
            );
            assert_eq!(
                ::core::mem::align_of::<TimeSpan>(),
                8usize,
                concat!("Alignment of ", stringify!(TimeSpan))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<TimeSpan>())).nanoseconds as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimeSpan),
                    "::",
                    stringify!(nanoseconds)
                )
            );
        }
        pub mod time {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4time10InitializeEv"]
                pub fn Initialize() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4time13IsInitializedEv"]
                pub fn IsInitialized() -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CalendarTime {
                pub year: root::s16,
                pub month: root::s8,
                pub day: root::s8,
                pub hour: root::s8,
                pub minute: root::s8,
                pub second: root::s8,
            }
            #[test]
            fn bindgen_test_layout_CalendarTime() {
                assert_eq!(
                    ::core::mem::size_of::<CalendarTime>(),
                    8usize,
                    concat!("Size of: ", stringify!(CalendarTime))
                );
                assert_eq!(
                    ::core::mem::align_of::<CalendarTime>(),
                    2usize,
                    concat!("Alignment of ", stringify!(CalendarTime))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<CalendarTime>())).year as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarTime),
                        "::",
                        stringify!(year)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<CalendarTime>())).month as *const _ as usize },
                    2usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarTime),
                        "::",
                        stringify!(month)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<CalendarTime>())).day as *const _ as usize },
                    3usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarTime),
                        "::",
                        stringify!(day)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<CalendarTime>())).hour as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarTime),
                        "::",
                        stringify!(hour)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<CalendarTime>())).minute as *const _ as usize
                    },
                    5usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarTime),
                        "::",
                        stringify!(minute)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<CalendarTime>())).second as *const _ as usize
                    },
                    6usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarTime),
                        "::",
                        stringify!(second)
                    )
                );
            }
            pub const DayOfTheWeek_Sunday: root::nn::time::DayOfTheWeek = 0;
            pub const DayOfTheWeek_Monday: root::nn::time::DayOfTheWeek = 1;
            pub const DayOfTheWeek_Tuesday: root::nn::time::DayOfTheWeek = 2;
            pub const DayOfTheWeek_Wednesday: root::nn::time::DayOfTheWeek = 3;
            pub const DayOfTheWeek_Thursday: root::nn::time::DayOfTheWeek = 4;
            pub const DayOfTheWeek_Friday: root::nn::time::DayOfTheWeek = 5;
            pub const DayOfTheWeek_Saturday: root::nn::time::DayOfTheWeek = 6;
            pub type DayOfTheWeek = u32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TimeZone {
                pub standardTimeName: [libc::c_char; 8usize],
                pub _9: bool,
                pub utcOffset: root::s32,
            }
            #[test]
            fn bindgen_test_layout_TimeZone() {
                assert_eq!(
                    ::core::mem::size_of::<TimeZone>(),
                    16usize,
                    concat!("Size of: ", stringify!(TimeZone))
                );
                assert_eq!(
                    ::core::mem::align_of::<TimeZone>(),
                    4usize,
                    concat!("Alignment of ", stringify!(TimeZone))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<TimeZone>())).standardTimeName as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TimeZone),
                        "::",
                        stringify!(standardTimeName)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<TimeZone>()))._9 as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TimeZone),
                        "::",
                        stringify!(_9)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<TimeZone>())).utcOffset as *const _ as usize },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TimeZone),
                        "::",
                        stringify!(utcOffset)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CalendarAdditionalInfo {
                pub dayOfTheWeek: root::nn::time::DayOfTheWeek,
                pub dayofYear: root::s32,
                pub timeZone: root::nn::time::TimeZone,
            }
            #[test]
            fn bindgen_test_layout_CalendarAdditionalInfo() {
                assert_eq!(
                    ::core::mem::size_of::<CalendarAdditionalInfo>(),
                    24usize,
                    concat!("Size of: ", stringify!(CalendarAdditionalInfo))
                );
                assert_eq!(
                    ::core::mem::align_of::<CalendarAdditionalInfo>(),
                    4usize,
                    concat!("Alignment of ", stringify!(CalendarAdditionalInfo))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<CalendarAdditionalInfo>())).dayOfTheWeek as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarAdditionalInfo),
                        "::",
                        stringify!(dayOfTheWeek)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<CalendarAdditionalInfo>())).dayofYear as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarAdditionalInfo),
                        "::",
                        stringify!(dayofYear)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<CalendarAdditionalInfo>())).timeZone as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CalendarAdditionalInfo),
                        "::",
                        stringify!(timeZone)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone)]
            pub struct PosixTime {
                pub time: u64,
            }
            #[test]
            fn bindgen_test_layout_PosixTime() {
                assert_eq!(
                    ::core::mem::size_of::<PosixTime>(),
                    8usize,
                    concat!("Size of: ", stringify!(PosixTime))
                );
                assert_eq!(
                    ::core::mem::align_of::<PosixTime>(),
                    8usize,
                    concat!("Alignment of ", stringify!(PosixTime))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<PosixTime>())).time as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PosixTime),
                        "::",
                        stringify!(time)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct StandardUserSystemClock {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_StandardUserSystemClock() {
                assert_eq!(
                    ::core::mem::size_of::<StandardUserSystemClock>(),
                    1usize,
                    concat!("Size of: ", stringify!(StandardUserSystemClock))
                );
                assert_eq!(
                    ::core::mem::align_of::<StandardUserSystemClock>(),
                    1usize,
                    concat!("Alignment of ", stringify!(StandardUserSystemClock))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4time23StandardUserSystemClock14GetCurrentTimeEPNS0_9PosixTimeE"]
                pub fn StandardUserSystemClock_GetCurrentTime(
                    arg1: *mut root::nn::time::PosixTime,
                ) -> root::Result;
            }
            impl StandardUserSystemClock {
                #[inline]
                pub unsafe fn GetCurrentTime(arg1: *mut root::nn::time::PosixTime) -> root::Result {
                    StandardUserSystemClock_GetCurrentTime(arg1)
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TimeZoneRule {
                _unused: [u8; 0],
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4time14ToCalendarTimeEPNS0_12CalendarTimeEPNS0_22CalendarAdditionalInfoERKNS0_9PosixTimeERKNS0_12TimeZoneRuleE"]
                pub fn ToCalendarTime(
                    arg1: *mut root::nn::time::CalendarTime,
                    arg2: *mut root::nn::time::CalendarAdditionalInfo,
                    arg3: *const root::nn::time::PosixTime,
                    arg4: *const root::nn::time::TimeZoneRule,
                ) -> root::Result;
            }
        }
        pub mod err {
            #[allow(unused_imports)]
            use crate::root;
            type ErrorCodeCategoryType = u32;

            #[repr(C)]
            pub struct ApplicationErrorArg {
                unk: u64,
                error_code: u32,
                language_code: *const root::nn::settings::LanguageCode,
                dialog_message: [u8; 2048usize],
                fullscreen_message: [u8; 2048usize],
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3err19ApplicationErrorArg29SetApplicationErrorCodeNumberEj"]
                pub fn ApplicationErrorArg_SetApplicationErrorCodeNumber(
                    this: *mut root::nn::err::ApplicationErrorArg,
                    error_code: u32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3err19ApplicationErrorArg16SetDialogMessageEPKc"]
                pub fn ApplicationErrorArg_SetDialogMessage(
                    this: *mut root::nn::err::ApplicationErrorArg,
                    message: *const u8,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3err19ApplicationErrorArg20SetFullScreenMessageEPKc"]
                pub fn ApplicationErrorArg_SetFullScreenMessage(
                    this: *mut root::nn::err::ApplicationErrorArg,
                    message: *const u8,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3err19ApplicationErrorArgC1Ev"]
                pub fn ApplicationErrorArg_ApplicationErrorArg(
                    this: *mut root::nn::err::ApplicationErrorArg,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3err19ApplicationErrorArgC2EjPKcS3_RKNS_8settings12LanguageCodeE"]
                pub fn ApplicationErrorArg_ApplicationErrorArg1(
                    this: *mut root::nn::err::ApplicationErrorArg,
                    error_code: u32,
                    dialog_message: *const u8,
                    fullscreen_message: *const u8,
                    languageCode: *const root::nn::settings::LanguageCode,
                );
            }
            impl ApplicationErrorArg {
                #[inline]
                pub unsafe fn SetApplicationErrorCodeNumber(&mut self, error_code: u32) {
                    ApplicationErrorArg_SetApplicationErrorCodeNumber(self, error_code)
                }
                #[inline]
                pub unsafe fn SetDialogMessage(&mut self, message: *const u8) {
                    ApplicationErrorArg_SetDialogMessage(self, message)
                }
                #[inline]
                pub unsafe fn SetFullScreenMessage(&mut self, message: *const u8) {
                    ApplicationErrorArg_SetFullScreenMessage(self, message)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut temp = ::core::mem::MaybeUninit::uninit();
                    ApplicationErrorArg_ApplicationErrorArg(temp.as_mut_ptr());
                    temp.assume_init()
                }
                #[inline]
                pub unsafe fn new_with_messages(
                    error_code: u32,
                    dialog_message: *const u8,
                    fullscreen_message: *const u8,
                    languageCode: *const root::nn::settings::LanguageCode,
                ) -> Self {
                    let mut temp = ::core::mem::MaybeUninit::uninit();
                    ApplicationErrorArg_ApplicationErrorArg1(
                        temp.as_mut_ptr(),
                        error_code,
                        dialog_message,
                        fullscreen_message,
                        languageCode,
                    );
                    temp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3err13MakeErrorCodeENS0_21ErrorCodeCategoryTypeEj"]
                pub fn MakeErrorCode(
                    err_category_type: root::nn::err::ErrorCodeCategoryType,
                    errorCodeNumber: u32,
                ) -> u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3err20ShowApplicationErrorERKNS0_19ApplicationErrorArgE"]
                pub fn ShowApplicationError(arg: *const root::nn::err::ApplicationErrorArg);
            }
        }

        pub mod os {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                pub struct InternalCriticalSection {
                    pub Image: u32,
                }
                #[test]
                fn bindgen_test_layout_InternalCriticalSection() {
                    assert_eq!(
                        ::core::mem::size_of::<InternalCriticalSection>(),
                        4usize,
                        concat!("Size of: ", stringify!(InternalCriticalSection))
                    );
                    assert_eq!(
                        ::core::mem::align_of::<InternalCriticalSection>(),
                        4usize,
                        concat!("Alignment of ", stringify!(InternalCriticalSection))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<InternalCriticalSection>())).Image as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(InternalCriticalSection),
                            "::",
                            stringify!(Image)
                        )
                    );
                }
                #[repr(C)]
                pub struct InternalConditionVariable {
                    pub Image: u32,
                }
                #[test]
                fn bindgen_test_layout_InternalConditionVariable() {
                    assert_eq!(
                        ::core::mem::size_of::<InternalConditionVariable>(),
                        4usize,
                        concat!("Size of: ", stringify!(InternalConditionVariable))
                    );
                    assert_eq!(
                        ::core::mem::align_of::<InternalConditionVariable>(),
                        4usize,
                        concat!("Alignment of ", stringify!(InternalConditionVariable))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<InternalConditionVariable>())).Image as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(InternalConditionVariable),
                            "::",
                            stringify!(Image)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn2os6detail22g_CommandLineParameterE"]
                    pub static mut g_CommandLineParameter: root::s32;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn2os6detail26g_CommandLineParameterArgvE"]
                    pub static mut g_CommandLineParameterArgv: *mut *mut libc::c_char;
                }
            }
            pub type Tick = u64;
            pub type LightEventType = u64;
            #[repr(C)]
            pub struct EventType {
                pub _x0: *mut root::nn::os::EventType,
                pub _x8: *mut root::nn::os::EventType,
                pub isSignaled: bool,
                pub initiallySignaled: bool,
                pub shouldAutoClear: bool,
                pub isInit: bool,
                pub signalCounter: u32,
                pub signalCounter2: u32,
                pub crit: root::nn::os::detail::InternalCriticalSection,
                pub condvar: root::nn::os::detail::InternalConditionVariable,
            }
            #[test]
            fn bindgen_test_layout_EventType() {
                assert_eq!(
                    ::core::mem::size_of::<EventType>(),
                    40usize,
                    concat!("Size of: ", stringify!(EventType))
                );
                assert_eq!(
                    ::core::mem::align_of::<EventType>(),
                    8usize,
                    concat!("Alignment of ", stringify!(EventType))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<EventType>()))._x0 as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(_x0)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<EventType>()))._x8 as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(_x8)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<EventType>())).isSignaled as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(isSignaled)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<EventType>())).initiallySignaled as *const _
                            as usize
                    },
                    17usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(initiallySignaled)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<EventType>())).shouldAutoClear as *const _ as usize
                    },
                    18usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(shouldAutoClear)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<EventType>())).isInit as *const _ as usize },
                    19usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(isInit)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<EventType>())).signalCounter as *const _ as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(signalCounter)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<EventType>())).signalCounter2 as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(signalCounter2)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<EventType>())).crit as *const _ as usize },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(crit)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<EventType>())).condvar as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EventType),
                        "::",
                        stringify!(condvar)
                    )
                );
            }
            pub type Event = root::nn::os::EventType;
            pub const EventClearMode_EventClearMode_ManualClear: root::nn::os::EventClearMode = 0;
            pub const EventClearMode_EventClearMode_AutoClear: root::nn::os::EventClearMode = 1;
            pub type EventClearMode = u32;
            #[repr(C)]
            pub struct ThreadType {
                pub _0: [u8; 64usize],
                pub State: u32,
                pub _44: bool,
                pub _45: bool,
                pub _46: u8,
                pub PriorityBase: u32,
                pub StackBase: *mut libc::c_void,
                pub Stack: *mut libc::c_void,
                pub StackSize: root::size_t,
                pub Arg: *mut libc::c_void,
                pub ThreadFunc: u64,
                pub _88: [u8; 256usize],
                pub Name: [libc::c_char; 32usize],
                pub Crit: root::nn::os::detail::InternalCriticalSection,
                pub Condvar: root::nn::os::detail::InternalConditionVariable,
                pub Handle: u32,
                pub padding: [u8; 24usize],
            }
            #[test]
            fn bindgen_test_layout_ThreadType() {
                assert_eq!(
                    ::core::mem::size_of::<ThreadType>(),
                    448usize,
                    concat!("Size of: ", stringify!(ThreadType))
                );
                assert_eq!(
                    ::core::mem::align_of::<ThreadType>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ThreadType))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>()))._0 as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(_0)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).State as *const _ as usize },
                    64usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(State)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>()))._44 as *const _ as usize },
                    68usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(_44)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>()))._45 as *const _ as usize },
                    69usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(_45)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>()))._46 as *const _ as usize },
                    70usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(_46)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ThreadType>())).PriorityBase as *const _ as usize
                    },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(PriorityBase)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ThreadType>())).StackBase as *const _ as usize
                    },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(StackBase)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).Stack as *const _ as usize },
                    88usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(Stack)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ThreadType>())).StackSize as *const _ as usize
                    },
                    96usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(StackSize)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).Arg as *const _ as usize },
                    104usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(Arg)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ThreadType>())).ThreadFunc as *const _ as usize
                    },
                    112usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(ThreadFunc)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>()))._88 as *const _ as usize },
                    120usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(_88)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).Name as *const _ as usize },
                    376usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(Name)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).Crit as *const _ as usize },
                    408usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(Crit)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).Condvar as *const _ as usize },
                    412usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(Condvar)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).Handle as *const _ as usize },
                    416usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(Handle)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ThreadType>())).padding as *const _ as usize },
                    420usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ThreadType),
                        "::",
                        stringify!(padding)
                    )
                );
            }
            #[repr(C)]
            pub struct MessageQueueType {
                pub _x0: u64,
                pub _x8: u64,
                pub _x10: u64,
                pub _x18: u64,
                pub Buffer: *mut libc::c_void,
                pub MaxCount: u32,
                pub Count: u32,
                pub Offset: u32,
                pub Initialized: bool,
                pub _x38: root::nn::os::detail::InternalCriticalSection,
                pub _x3C: root::nn::os::detail::InternalConditionVariable,
                pub _x40: root::nn::os::detail::InternalConditionVariable,
            }
            #[test]
            fn bindgen_test_layout_MessageQueueType() {
                assert_eq!(
                    ::core::mem::size_of::<MessageQueueType>(),
                    72usize,
                    concat!("Size of: ", stringify!(MessageQueueType))
                );
                assert_eq!(
                    ::core::mem::align_of::<MessageQueueType>(),
                    8usize,
                    concat!("Alignment of ", stringify!(MessageQueueType))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>()))._x0 as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(_x0)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>()))._x8 as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(_x8)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>()))._x10 as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(_x10)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>()))._x18 as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(_x18)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>())).Buffer as *const _ as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(Buffer)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>())).MaxCount as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(MaxCount)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>())).Count as *const _ as usize
                    },
                    44usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(Count)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>())).Offset as *const _ as usize
                    },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(Offset)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>())).Initialized as *const _
                            as usize
                    },
                    52usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(Initialized)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>()))._x38 as *const _ as usize
                    },
                    56usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(_x38)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>()))._x3C as *const _ as usize
                    },
                    60usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(_x3C)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<MessageQueueType>()))._x40 as *const _ as usize
                    },
                    64usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MessageQueueType),
                        "::",
                        stringify!(_x40)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConditionVariableType {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_ConditionVariableType() {
                assert_eq!(
                    ::core::mem::size_of::<ConditionVariableType>(),
                    1usize,
                    concat!("Size of: ", stringify!(ConditionVariableType))
                );
                assert_eq!(
                    ::core::mem::align_of::<ConditionVariableType>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ConditionVariableType))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SystemEvent {
                _unused: [u8; 0x28],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SystemEventType {
                pub _unused: [u8; 0x29],
            }
            impl SystemEventType {
                pub fn new(clear_mode: SystemEventClearMode) -> Self {
                    let x = Self {
                        _unused: [0;0x29],
                    };
                    unsafe { CreateSystemEvent(&x, clear_mode, false) };
                    x
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub enum SystemEventClearMode {
                Manual = 0,
                Auto = 1,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11SetHostArgcEi"]
                pub fn SetHostArgc(arg1: root::s32);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11GetHostArgcEv"]
                pub fn GetHostArgc() -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11SetHostArgvEPPc"]
                pub fn SetHostArgv(arg1: *mut *mut libc::c_char);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11GetHostArgvEv"]
                pub fn GetHostArgv() -> *mut *mut libc::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os30InitializeVirtualAddressMemoryEv"]
                pub fn InitializeVirtualAddressMemory();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os21AllocateAddressRegionEPmm"]
                pub fn AllocateAddressRegion(arg1: *mut u64, arg2: u64) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os14AllocateMemoryEPmm"]
                pub fn AllocateMemory(arg1: *mut u64, arg2: u64) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os19AllocateMemoryPagesEmm"]
                pub fn AllocateMemoryPages(arg1: u64, arg2: u64) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os19AllocateMemoryBlockEPmm"]
                pub fn AllocateMemoryBlock(arg1: *mut u64, arg2: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os15FreeMemoryBlockEmm"]
                pub fn FreeMemoryBlock(arg1: u64, arg2: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os17SetMemoryHeapSizeEm"]
                pub fn SetMemoryHeapSize(arg1: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os17CreateSystemEventEPNS0_15SystemEventTypeENS0_14EventClearModeEb"]
                pub fn CreateSystemEvent(arg1: *const SystemEventType, clear_mode: SystemEventClearMode, skip_init: bool) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os18TryWaitSystemEventEPNS0_15SystemEventTypeE"]
                pub fn TryWaitSystemEvent(arg1: *const SystemEventType) -> bool;
            }
            #[repr(C)]
            pub struct MutexType {
                pub impl_: root::nnosMutexType,
            }
            #[test]
            fn bindgen_test_layout_MutexType() {
                assert_eq!(
                    ::core::mem::size_of::<MutexType>(),
                    28usize,
                    concat!("Size of: ", stringify!(MutexType))
                );
                assert_eq!(
                    ::core::mem::align_of::<MutexType>(),
                    4usize,
                    concat!("Alignment of ", stringify!(MutexType))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<MutexType>())).impl_ as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MutexType),
                        "::",
                        stringify!(impl_)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os15InitializeMutexEPNS0_9MutexTypeEbi"]
                pub fn InitializeMutex(
                    arg1: *mut root::nn::os::MutexType,
                    arg2: bool,
                    arg3: root::s32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os13FinalizeMutexEPNS0_9MutexTypeE"]
                pub fn FinalizeMutex(arg1: *mut root::nn::os::MutexType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os9LockMutexEPNS0_9MutexTypeE"]
                pub fn LockMutex(arg1: *mut root::nn::os::MutexType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os12TryLockMutexEPNS0_9MutexTypeE"]
                pub fn TryLockMutex(arg1: *mut root::nn::os::MutexType) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11UnlockMutexEPNS0_9MutexTypeE"]
                pub fn UnlockMutex(arg1: *mut root::nn::os::MutexType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os28IsMutexLockedByCurrentThreadEPKNS0_9MutexTypeE"]
                pub fn IsMutexLockedByCurrentThread(arg1: *const root::nn::os::MutexType) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os22InitializeMessageQueueEPNS0_16MessageQueueTypeEPmm"]
                pub fn InitializeMessageQueue(
                    arg1: *mut root::nn::os::MessageQueueType,
                    buf: *mut u64,
                    queueCount: u64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os20FinalizeMessageQueueEPNS0_16MessageQueueTypeE"]
                pub fn FinalizeMessageQueue(arg1: *mut root::nn::os::MessageQueueType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os19TrySendMessageQueueEPNS0_16MessageQueueTypeEm"]
                pub fn TrySendMessageQueue(
                    arg1: *mut root::nn::os::MessageQueueType,
                    arg2: u64,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os16SendMessageQueueEPNS0_16MessageQueueTypeEm"]
                pub fn SendMessageQueue(arg1: *mut root::nn::os::MessageQueueType, arg2: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os21TimedSendMessageQueueEPNS0_16MessageQueueTypeEmNS_8TimeSpanE"]
                pub fn TimedSendMessageQueue(
                    arg1: *mut root::nn::os::MessageQueueType,
                    arg2: u64,
                    arg3: root::nn::TimeSpan,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os22TryReceiveMessageQueueEPmPNS0_16MessageQueueTypeE"]
                pub fn TryReceiveMessageQueue(
                    out: *mut u64,
                    arg1: *mut root::nn::os::MessageQueueType,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os19ReceiveMessageQueueEPmPNS0_16MessageQueueTypeE"]
                pub fn ReceiveMessageQueue(
                    out: *mut u64,
                    arg1: *mut root::nn::os::MessageQueueType,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os24TimedReceiveMessageQueueEPmPNS0_16MessageQueueTypeENS_8TimeSpanE"]
                pub fn TimedReceiveMessageQueue(
                    out: *mut u64,
                    arg1: *mut root::nn::os::MessageQueueType,
                    arg2: root::nn::TimeSpan,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os19TryPeekMessageQueueEPmPKNS0_16MessageQueueTypeE"]
                pub fn TryPeekMessageQueue(
                    arg1: *mut u64,
                    arg2: *const root::nn::os::MessageQueueType,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os16PeekMessageQueueEPmPKNS0_16MessageQueueTypeE"]
                pub fn PeekMessageQueue(
                    arg1: *mut u64,
                    arg2: *const root::nn::os::MessageQueueType,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os21TimedPeekMessageQueueEPmPKNS0_16MessageQueueTypeE"]
                pub fn TimedPeekMessageQueue(
                    arg1: *mut u64,
                    arg2: *const root::nn::os::MessageQueueType,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os18TryJamMessageQueueEPNS0_16MessageQueueTypeEm"]
                pub fn TryJamMessageQueue(
                    arg1: *mut root::nn::os::MessageQueueType,
                    arg2: u64,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os15JamMessageQueueEPNS0_16MessageQueueTypeEm"]
                pub fn JamMessageQueue(arg1: *mut root::nn::os::MessageQueueType, arg2: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os20TimedJamMessageQueueEPNS0_16MessageQueueTypeEmNS_8TimeSpanE"]
                pub fn TimedJamMessageQueue(
                    arg1: *mut root::nn::os::MessageQueueType,
                    arg2: u64,
                    arg3: root::nn::TimeSpan,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os27InitializeConditionVariableEPNS0_21ConditionVariableTypeE"]
                pub fn InitializeConditionVariable(arg1: *mut root::nn::os::ConditionVariableType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os25FinalizeConditionVariableEPNS0_21ConditionVariableTypeE"]
                pub fn FinalizeConditionVariable(arg1: *mut root::nn::os::ConditionVariableType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os23SignalConditionVariableEPNS0_21ConditionVariableTypeE"]
                pub fn SignalConditionVariable(arg1: *mut root::nn::os::ConditionVariableType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os26BroadcastConditionVariableEPNS0_21ConditionVariableTypeE"]
                pub fn BroadcastConditionVariable(arg1: *mut root::nn::os::ConditionVariableType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os21WaitConditionVariableEPNS0_21ConditionVariableTypeE"]
                pub fn WaitConditionVariable(arg1: *mut root::nn::os::ConditionVariableType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os26TimedWaitConditionVariableEPNS0_21ConditionVariableTypeEPNS0_9MutexTypeENS_8TimeSpanE"]
                pub fn TimedWaitConditionVariable(
                    arg1: *mut root::nn::os::ConditionVariableType,
                    arg2: *mut root::nn::os::MutexType,
                    arg3: root::nn::TimeSpan,
                ) -> u8;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os12CreateThreadEPNS0_10ThreadTypeEPFvPvES3_S3_mii"]
                pub fn CreateThread(
                    arg1: *mut root::nn::os::ThreadType,
                    arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
                    arg: *mut libc::c_void,
                    srcStack: *mut libc::c_void,
                    stackSize: u64,
                    priority: root::s32,
                    coreNum: root::s32,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os12CreateThreadEPNS0_10ThreadTypeEPFvPvES3_S3_mi"]
                pub fn CreateThread1(
                    arg1: *mut root::nn::os::ThreadType,
                    arg2: unsafe extern "C" fn (arg1: *mut libc::c_void),
                    arg: *mut libc::c_void,
                    srcStack: *mut libc::c_void,
                    stackSize: u64,
                    priority: root::s32
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os13DestroyThreadEPNS0_10ThreadTypeE"]
                pub fn DestroyThread(arg1: *mut root::nn::os::ThreadType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11StartThreadEPNS0_10ThreadTypeE"]
                pub fn StartThread(arg1: *mut root::nn::os::ThreadType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os13SetThreadNameEPNS0_10ThreadTypeEPKc"]
                pub fn SetThreadName(
                    arg1: *mut root::nn::os::ThreadType,
                    threadName: *const libc::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os20SetThreadNamePointerEPNS0_10ThreadTypeEPKc"]
                pub fn SetThreadNamePointer(
                    arg1: *mut root::nn::os::ThreadType,
                    arg2: *const libc::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os20GetThreadNamePointerEPKNS0_10ThreadTypeE"]
                pub fn GetThreadNamePointer(
                    arg1: *const root::nn::os::ThreadType,
                ) -> *mut libc::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os16GetCurrentThreadEv"]
                pub fn GetCurrentThread() -> *mut root::nn::os::ThreadType;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os20ChangeThreadPriorityEPNS0_10ThreadTypeEi"]
                pub fn ChangeThreadPriority(
                    thread: *mut root::nn::os::ThreadType,
                    priority: root::s32,
                ) -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os17GetThreadPriorityEPKNS0_10ThreadTypeE"]
                pub fn GetThreadPriority(thread: *const root::nn::os::ThreadType) -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11YieldThreadEv"]
                pub fn YieldThread();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os13SuspendThreadEPNS0_10ThreadTypeE"]
                pub fn SuspendThread(arg1: *mut root::nn::os::ThreadType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os12ResumeThreadEPNS0_10ThreadTypeE"]
                pub fn ResumeThread(arg1: *mut root::nn::os::ThreadType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11SleepThreadENS_8TimeSpanE"]
                pub fn SleepThread(arg1: root::nn::TimeSpan);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os10WaitThreadEPNS0_10ThreadTypeE"]
                pub fn WaitThread(arg1: *mut root::nn::os::ThreadType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os15InitializeEventEPNS0_9EventTypeEbNS0_14EventClearModeE"]
                pub fn InitializeEvent(
                    arg1: *mut root::nn::os::EventType,
                    initiallySignaled: bool,
                    clearMode: root::nn::os::EventClearMode,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os13FinalizeEventEPNS0_9EventTypeE"]
                pub fn FinalizeEvent(arg1: *mut root::nn::os::EventType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os11SignalEventEPNS0_9EventTypeE"]
                pub fn SignalEvent(arg1: *mut root::nn::os::EventType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os9WaitEventEPNS0_9EventTypeE"]
                pub fn WaitEvent(arg1: *mut root::nn::os::EventType);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os12TryWaitEventEPNS0_9EventTypeE"]
                pub fn TryWaitEvent(arg1: *mut root::nn::os::EventType) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os14TimedWaitEventEPNS0_9EventTypeENS_8TimeSpanE"]
                pub fn TimedWaitEvent(
                    arg1: *mut root::nn::os::EventType,
                    arg2: root::nn::TimeSpan,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os10ClearEventEPNS0_9EventTypeE"]
                pub fn ClearEvent(arg1: *mut root::nn::os::EventType);
            }
            #[repr(C)]
            pub struct CpuRegister {
                #[doc = "< 64-bit AArch64 register view."]
                pub x: root::__BindgenUnionField<u64>,
                #[doc = "< 32-bit AArch64 register view."]
                pub w: root::__BindgenUnionField<u32>,
                #[doc = "< AArch32 register view."]
                pub r: root::__BindgenUnionField<u32>,
                pub bindgen_union_field: u64,
            }
            #[test]
            fn bindgen_test_layout_CpuRegister() {
                assert_eq!(
                    ::core::mem::size_of::<CpuRegister>(),
                    8usize,
                    concat!("Size of: ", stringify!(CpuRegister))
                );
                assert_eq!(
                    ::core::mem::align_of::<CpuRegister>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CpuRegister))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<CpuRegister>())).x as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CpuRegister),
                        "::",
                        stringify!(x)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<CpuRegister>())).w as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CpuRegister),
                        "::",
                        stringify!(w)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<CpuRegister>())).r as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CpuRegister),
                        "::",
                        stringify!(r)
                    )
                );
            }
            #[doc = " Armv8 NEON register."]
            #[repr(C)]
            #[repr(align(16))]
            pub struct FpuRegister {
                #[doc = "< 128-bit vector view."]
                pub v: root::__BindgenUnionField<u128>,
                #[doc = "< 64-bit double-precision view."]
                pub d: root::__BindgenUnionField<f64>,
                #[doc = "< 32-bit single-precision view."]
                pub s: root::__BindgenUnionField<f32>,
                pub bindgen_union_field: u128,
            }
            #[test]
            fn bindgen_test_layout_FpuRegister() {
                assert_eq!(
                    ::core::mem::size_of::<FpuRegister>(),
                    16usize,
                    concat!("Size of: ", stringify!(FpuRegister))
                );
                assert_eq!(
                    ::core::mem::align_of::<FpuRegister>(),
                    16usize,
                    concat!("Alignment of ", stringify!(FpuRegister))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<FpuRegister>())).v as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FpuRegister),
                        "::",
                        stringify!(v)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<FpuRegister>())).d as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FpuRegister),
                        "::",
                        stringify!(d)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<FpuRegister>())).s as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FpuRegister),
                        "::",
                        stringify!(s)
                    )
                );
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct UserExceptionInfo {
                #[doc = "< See \\ref ThreadExceptionDesc."]
                pub ErrorDescription: u32,
                pub pad: [u32; 3usize],
                #[doc = "< GPRs 0..28. Note: also contains AArch32 registers."]
                pub CpuRegisters: [root::nn::os::CpuRegister; 29usize],
                #[doc = "< Frame pointer."]
                pub FP: root::nn::os::CpuRegister,
                #[doc = "< Link register."]
                pub LR: root::nn::os::CpuRegister,
                #[doc = "< Stack pointer."]
                pub SP: root::nn::os::CpuRegister,
                #[doc = "< Program counter (elr_el1)."]
                pub PC: root::nn::os::CpuRegister,
                pub padding: u64,
                #[doc = "< 32 general-purpose NEON registers."]
                pub FpuRegisters: [root::nn::os::FpuRegister; 32usize],
                #[doc = "< pstate & 0xFF0FFE20"]
                pub PState: u32,
                pub AFSR0: u32,
                pub AFSR1: u32,
                pub ESR: u32,
                #[doc = "< Fault Address Register."]
                pub FAR: root::nn::os::CpuRegister,
            }
            #[test]
            fn bindgen_test_layout_UserExceptionInfo() {
                assert_eq!(
                    ::core::mem::size_of::<UserExceptionInfo>(),
                    832usize,
                    concat!("Size of: ", stringify!(UserExceptionInfo))
                );
                assert_eq!(
                    ::core::mem::align_of::<UserExceptionInfo>(),
                    16usize,
                    concat!("Alignment of ", stringify!(UserExceptionInfo))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).ErrorDescription as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(ErrorDescription)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).pad as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(pad)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).CpuRegisters as *const _
                            as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(CpuRegisters)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).FP as *const _ as usize
                    },
                    248usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(FP)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).LR as *const _ as usize
                    },
                    256usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(LR)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).SP as *const _ as usize
                    },
                    264usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(SP)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).PC as *const _ as usize
                    },
                    272usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(PC)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).padding as *const _ as usize
                    },
                    280usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(padding)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).FpuRegisters as *const _
                            as usize
                    },
                    288usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(FpuRegisters)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).PState as *const _ as usize
                    },
                    800usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(PState)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).AFSR0 as *const _ as usize
                    },
                    804usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(AFSR0)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).AFSR1 as *const _ as usize
                    },
                    808usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(AFSR1)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).ESR as *const _ as usize
                    },
                    812usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(ESR)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<UserExceptionInfo>())).FAR as *const _ as usize
                    },
                    816usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UserExceptionInfo),
                        "::",
                        stringify!(FAR)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os23SetUserExceptionHandlerEPFvPNS0_17UserExceptionInfoEEPvmS2_"]
                #[allow(improper_ctypes)]
                pub fn SetUserExceptionHandler(
                    arg1: ::core::option::Option<
                        unsafe extern "C" fn(arg1: *mut root::nn::os::UserExceptionInfo),
                    >,
                    arg2: *mut libc::c_void,
                    arg3: root::ulong,
                    arg4: *mut root::nn::os::UserExceptionInfo,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os19GenerateRandomBytesEPvm"]
                pub fn GenerateRandomBytes(arg1: *mut libc::c_void, arg2: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os13GetSystemTickEv"]
                pub fn GetSystemTick() -> root::nn::os::Tick;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2os26GetThreadAvailableCoreMaskEv"]
                pub fn GetThreadAvailableCoreMask() -> u64;
            }
        }
        pub mod settings {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod system {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                pub struct FirmwareVersion {
                    pub major: u8,
                    pub minor: u8,
                    pub micro: u8,
                    pub padding1: u8,
                    pub revision_major: u8,
                    pub revision_minor: u8,
                    pub padding2: u8,
                    pub padding3: u8,
                    pub platform: [libc::c_char; 32usize],
                    pub version_hash: [libc::c_char; 64usize],
                    pub display_version: [libc::c_char; 24usize],
                    pub display_title: [libc::c_char; 128usize],
                }
                #[test]
                fn bindgen_test_layout_FirmwareVersion() {
                    assert_eq!(
                        ::core::mem::size_of::<FirmwareVersion>(),
                        256usize,
                        concat!("Size of: ", stringify!(FirmwareVersion))
                    );
                    assert_eq!(
                        ::core::mem::align_of::<FirmwareVersion>(),
                        1usize,
                        concat!("Alignment of ", stringify!(FirmwareVersion))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).major as *const _ as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(major)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).minor as *const _ as usize
                        },
                        1usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(minor)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).micro as *const _ as usize
                        },
                        2usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(micro)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).padding1 as *const _
                                as usize
                        },
                        3usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(padding1)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).revision_major as *const _
                                as usize
                        },
                        4usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(revision_major)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).revision_minor as *const _
                                as usize
                        },
                        5usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(revision_minor)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).padding2 as *const _
                                as usize
                        },
                        6usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(padding2)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).padding3 as *const _
                                as usize
                        },
                        7usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(padding3)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).platform as *const _
                                as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(platform)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).version_hash as *const _
                                as usize
                        },
                        40usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(version_hash)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).display_version as *const _
                                as usize
                        },
                        104usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(display_version)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<FirmwareVersion>())).display_title as *const _
                                as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(FirmwareVersion),
                            "::",
                            stringify!(display_title)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn8settings6system18GetFirmwareVersionEPNS1_15FirmwareVersionE"]
                    pub fn GetFirmwareVersion(
                        arg1: *mut root::nn::settings::system::FirmwareVersion,
                    ) -> root::Result;
                }
            }
            pub const Language_Language_Japanese: root::nn::settings::Language = 0;
            pub const Language_Language_English: root::nn::settings::Language = 1;
            pub const Language_Language_French: root::nn::settings::Language = 2;
            pub const Language_Language_German: root::nn::settings::Language = 3;
            pub const Language_Language_Italian: root::nn::settings::Language = 4;
            pub const Language_Language_Spanish: root::nn::settings::Language = 5;
            pub const Language_Language_Chinese: root::nn::settings::Language = 6;
            pub const Language_Language_Korean: root::nn::settings::Language = 7;
            pub const Language_Language_Dutch: root::nn::settings::Language = 8;
            pub const Language_Language_Portuguese: root::nn::settings::Language = 9;
            pub const Language_Language_Russian: root::nn::settings::Language = 10;
            pub const Language_Language_Taiwanese: root::nn::settings::Language = 11;
            pub const Language_Language_BritishEnglish: root::nn::settings::Language = 12;
            pub const Language_Language_CanadianFrench: root::nn::settings::Language = 13;
            pub const Language_Language_LatinAmericanSpanish: root::nn::settings::Language = 14;
            pub type Language = u32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LanguageCode {
                pub code: [libc::c_char; 8usize],
            }
            #[test]
            fn bindgen_test_layout_LanguageCode() {
                assert_eq!(
                    ::core::mem::size_of::<LanguageCode>(),
                    8usize,
                    concat!("Size of: ", stringify!(LanguageCode))
                );
                assert_eq!(
                    ::core::mem::align_of::<LanguageCode>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LanguageCode))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<LanguageCode>())).code as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LanguageCode),
                        "::",
                        stringify!(code)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn8settings12LanguageCode4MakeENS0_8LanguageE"]
                pub fn LanguageCode_Make(
                    arg1: root::nn::settings::Language,
                ) -> root::nn::settings::LanguageCode;
            }
            impl LanguageCode {
                #[inline]
                pub unsafe fn Make(
                    arg1: root::nn::settings::Language,
                ) -> root::nn::settings::LanguageCode {
                    LanguageCode_Make(arg1)
                }
            }
        }
        pub mod oe {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type FocusHandlingMode = root::s32;
            pub type PerformanceMode = u32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DisplayVersion {
                pub name: [libc::c_char; 16usize],
            }
            #[test]
            fn bindgen_test_layout_DisplayVersion() {
                assert_eq!(
                    ::core::mem::size_of::<DisplayVersion>(),
                    16usize,
                    concat!("Size of: ", stringify!(DisplayVersion))
                );
                assert_eq!(
                    ::core::mem::align_of::<DisplayVersion>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DisplayVersion))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<DisplayVersion>())).name as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DisplayVersion),
                        "::",
                        stringify!(name)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe10InitializeEv"]
                pub fn Initialize();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe27SetPerformanceConfigurationENS0_15PerformanceModeEi"]
                pub fn SetPerformanceConfiguration(
                    arg1: root::nn::oe::PerformanceMode,
                    arg2: u32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe27GetPerformanceConfigurationENS0_15PerformanceModeE"]
                pub fn GetPerformanceConfiguration(arg1: root::nn::oe::PerformanceMode) -> u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe16GetOperationModeEv"]
                pub fn GetOperationMode() -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe18GetPerformanceModeEv"]
                pub fn GetPerformanceMode() -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe28SetResumeNotificationEnabledEb"]
                pub fn SetResumeNotificationEnabled(arg1: bool);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe42SetOperationModeChangedNotificationEnabledEb"]
                pub fn SetOperationModeChangedNotificationEnabled(arg1: bool);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe44SetPerformanceModeChangedNotificationEnabledEb"]
                pub fn SetPerformanceModeChangedNotificationEnabled(arg1: bool);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe20SetFocusHandlingModeEi"]
                pub fn SetFocusHandlingMode(arg1: root::nn::oe::FocusHandlingMode);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe25TryPopNotificationMessageEPj"]
                pub fn TryPopNotificationMessage(arg1: *mut u32) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe20GetCurrentFocusStateEv"]
                pub fn GetCurrentFocusState() -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe23EnableGamePlayRecordingEPvm"]
                pub fn EnableGamePlayRecording(arg1: *mut libc::c_void, arg2: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe37IsUserInactivityDetectionTimeExtendedEv"]
                pub fn IsUserInactivityDetectionTimeExtended() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe38SetUserInactivityDetectionTimeExtendedEb"]
                pub fn SetUserInactivityDetectionTimeExtended(arg1: bool);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe17FinishStartupLogoEv"]
                pub fn FinishStartupLogo();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe18GetDesiredLanguageEv"]
                pub fn GetDesiredLanguage() -> root::nn::settings::LanguageCode;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe17GetDisplayVersionEPNS0_14DisplayVersionE"]
                pub fn GetDisplayVersion(arg1: *mut root::nn::oe::DisplayVersion);
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub enum CpuBoostMode {
                Disabled = 0,
                Boost = 1,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe15SetCpuBoostModeENS0_12CpuBoostModeE"]
                pub fn SetCpuBoostMode(mode: CpuBoostMode);
            }
            extern "C" {
                #[link_name = "_ZN2nn2oe14RestartProgramEPKvm"]
                pub fn RestartProgram(argv: *const libc::c_void, argc: u32) -> !;
            }
            pub fn RestartProgramNoArgs() -> ! {
                unsafe {
                    RestartProgram("".as_ptr() as _, 0)
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe28RequestToRelaunchApplicationEv"]
                pub fn RequestToRelaunchApplication() -> !;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2oe15ExitApplicationEv"]
                pub fn ExitApplication() -> !;
            }
        }
        pub mod account {
            #[allow(unused_imports)]
            use self::super::super::super::root;

            //pub type Nickname = [libc::c_char; 33usize];
            #[repr(transparent)]
            pub struct Nickname(pub [libc::c_char; 33usize]);

            impl Nickname {
                pub fn new() -> Self {
                    Self([0; 33])
                }
            }

            #[cfg(not(feature = "rustc-dep-of-std"))]
            impl core::fmt::Display for Nickname {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    let mut i = 0;
                    while self.0[i] != 0 {
                        i += 1;
                    }

                    write!(f, "{}", unsafe {
                        alloc::str::from_utf8_unchecked(&self.0[..i])
                    })
                }
            }

            #[repr(C)]
            pub struct Uid {
                pub id: [u64; 2usize],
            }

            impl Uid {
                pub fn new() -> Self {
                    Self { id: [0, 0] }
                }
            }

            #[test]
            fn bindgen_test_layout_Uid() {
                assert_eq!(
                    ::core::mem::size_of::<Uid>(),
                    16usize,
                    concat!("Size of: ", stringify!(Uid))
                );
                assert_eq!(
                    ::core::mem::align_of::<Uid>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Uid))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Uid>()))._x0 as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(Uid), "::", stringify!(_x0))
                );
            }
            pub type NetworkServiceAccountId = u64;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UserHandle {
                _unused: [u8; 0],
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account10InitializeEv"]
                pub fn Initialize();
            }

            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account15ShowUserCreatorEv"]
                pub fn ShowUserCreator();
            }

            pub mod detail {
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn7account6detail13IsInitializedEv"]
                    pub fn IsInitialized() -> bool;
                }
            }

            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account12ListAllUsersEPiPNS0_3UidEi"]
                pub fn ListAllUsers(
                    arg1: *mut root::s32,
                    arg2: *mut root::nn::account::Uid,
                    numUsers: root::s32,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account8OpenUserEPNS0_10UserHandleERKNS0_3UidE"]
                pub fn OpenUser(
                    arg1: *mut root::nn::account::UserHandle,
                    arg2: *const root::nn::account::Uid,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account32IsNetworkServiceAccountAvailableEPbRKNS0_10UserHandleE"]
                pub fn IsNetworkServiceAccountAvailable(
                    out: *mut bool,
                    arg1: *const root::nn::account::UserHandle,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account9CloseUserERKNS0_10UserHandleE"]
                pub fn CloseUser(arg1: *const root::nn::account::UserHandle);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account36EnsureNetworkServiceAccountAvailableERKNS0_10UserHandleE"]
                pub fn EnsureNetworkServiceAccountAvailable(
                    userHandle: *const root::nn::account::UserHandle,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account44EnsureNetworkServiceAccountIdTokenCacheAsyncEPNS0_12AsyncContextERKNS0_10UserHandleE"]
                pub fn EnsureNetworkServiceAccountIdTokenCacheAsync(
                    arg1: *mut root::nn::account::AsyncContext,
                    arg2: *const root::nn::account::UserHandle,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account37LoadNetworkServiceAccountIdTokenCacheEPmPcmRKNS0_10UserHandleE"]
                pub fn LoadNetworkServiceAccountIdTokenCache(
                    arg1: *mut u64,
                    arg2: *mut libc::c_char,
                    arg3: u64,
                    arg4: *const root::nn::account::UserHandle,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account17GetLastOpenedUserEPNS0_3UidE"]
                pub fn GetLastOpenedUser(arg1: *mut root::nn::account::Uid) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account11GetNicknameEPNS0_8NicknameERKNS0_3UidE"]
                pub fn GetNickname(
                    nickname: *mut root::nn::account::Nickname,
                    userID: *const root::nn::account::Uid,
                ) -> root::Result;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AsyncContext {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AsyncContext() {
                assert_eq!(
                    ::core::mem::size_of::<AsyncContext>(),
                    1usize,
                    concat!("Size of: ", stringify!(AsyncContext))
                );
                assert_eq!(
                    ::core::mem::align_of::<AsyncContext>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AsyncContext))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account12AsyncContext7HasDoneEPb"]
                pub fn AsyncContext_HasDone(
                    this: *mut root::nn::account::AsyncContext,
                    arg1: *mut bool,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account12AsyncContext9GetResultEv"]
                pub fn AsyncContext_GetResult(
                    this: *mut root::nn::account::AsyncContext,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account12AsyncContext6CancelEv"]
                pub fn AsyncContext_Cancel(
                    this: *mut root::nn::account::AsyncContext,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account12AsyncContext14GetSystemEventEPNS_2os11SystemEventE"]
                pub fn AsyncContext_GetSystemEvent(
                    this: *mut root::nn::account::AsyncContext,
                    arg1: *mut root::nn::os::SystemEvent,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7account12AsyncContextC1Ev"]
                pub fn AsyncContext_AsyncContext(this: *mut root::nn::account::AsyncContext);
            }
            impl AsyncContext {
                #[inline]
                pub unsafe fn HasDone(&mut self, arg1: *mut bool) -> root::Result {
                    AsyncContext_HasDone(self, arg1)
                }
                #[inline]
                pub unsafe fn GetResult(&mut self) -> root::Result {
                    AsyncContext_GetResult(self)
                }
                #[inline]
                pub unsafe fn Cancel(&mut self) -> root::Result {
                    AsyncContext_Cancel(self)
                }
                #[inline]
                pub unsafe fn GetSystemEvent(
                    &mut self,
                    arg1: *mut root::nn::os::SystemEvent,
                ) -> root::Result {
                    AsyncContext_GetSystemEvent(self, arg1)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                    AsyncContext_AsyncContext(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
            }
        }
        pub mod fs {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type UserId = u64;
            #[repr(C)]
            pub struct DirectoryEntry {
                pub name: [libc::c_char; 769usize],
                pub _x302: [libc::c_char; 3usize],
                pub type_: u8,
                pub _x304: libc::c_char,
                pub fileSize: root::s64,
            }
            #[test]
            fn bindgen_test_layout_DirectoryEntry() {
                assert_eq!(
                    ::core::mem::size_of::<DirectoryEntry>(),
                    784usize,
                    concat!("Size of: ", stringify!(DirectoryEntry))
                );
                assert_eq!(
                    ::core::mem::align_of::<DirectoryEntry>(),
                    8usize,
                    concat!("Alignment of ", stringify!(DirectoryEntry))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<DirectoryEntry>())).name as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DirectoryEntry),
                        "::",
                        stringify!(name)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<DirectoryEntry>()))._x302 as *const _ as usize
                    },
                    769usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DirectoryEntry),
                        "::",
                        stringify!(_x302)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<DirectoryEntry>())).type_ as *const _ as usize
                    },
                    772usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DirectoryEntry),
                        "::",
                        stringify!(type_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<DirectoryEntry>()))._x304 as *const _ as usize
                    },
                    773usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DirectoryEntry),
                        "::",
                        stringify!(_x304)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<DirectoryEntry>())).fileSize as *const _ as usize
                    },
                    776usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DirectoryEntry),
                        "::",
                        stringify!(fileSize)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FileHandle {
                pub handle: *mut libc::c_void,
            }
            #[test]
            fn bindgen_test_layout_FileHandle() {
                assert_eq!(
                    ::core::mem::size_of::<FileHandle>(),
                    8usize,
                    concat!("Size of: ", stringify!(FileHandle))
                );
                assert_eq!(
                    ::core::mem::align_of::<FileHandle>(),
                    8usize,
                    concat!("Alignment of ", stringify!(FileHandle))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<FileHandle>())).handle as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FileHandle),
                        "::",
                        stringify!(handle)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DirectoryHandle {
                pub handle: *mut libc::c_void,
            }
            #[test]
            fn bindgen_test_layout_DirectoryHandle() {
                assert_eq!(
                    ::core::mem::size_of::<DirectoryHandle>(),
                    8usize,
                    concat!("Size of: ", stringify!(DirectoryHandle))
                );
                assert_eq!(
                    ::core::mem::align_of::<DirectoryHandle>(),
                    8usize,
                    concat!("Alignment of ", stringify!(DirectoryHandle))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<DirectoryHandle>())).handle as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DirectoryHandle),
                        "::",
                        stringify!(handle)
                    )
                );
            }
            pub const DirectoryEntryType_DirectoryEntryType_Directory:
                root::nn::fs::DirectoryEntryType = 0;
            pub const DirectoryEntryType_DirectoryEntryType_File: root::nn::fs::DirectoryEntryType =
                1;
            pub type DirectoryEntryType = u32;
            pub const OpenMode_OpenMode_Read: root::nn::fs::OpenMode = 1;
            pub const OpenMode_OpenMode_Write: root::nn::fs::OpenMode = 2;
            pub const OpenMode_OpenMode_Append: root::nn::fs::OpenMode = 4;
            pub const OpenMode_OpenMode_ReadWrite: root::nn::fs::OpenMode = 3;
            pub type OpenMode = u32;
            pub const OpenDirectoryMode_OpenDirectoryMode_Directory:
                root::nn::fs::OpenDirectoryMode = 1;
            pub const OpenDirectoryMode_OpenDirectoryMode_File: root::nn::fs::OpenDirectoryMode = 2;
            pub const OpenDirectoryMode_OpenDirectoryMode_All: root::nn::fs::OpenDirectoryMode = 3;
            pub type OpenDirectoryMode = u32;
            pub const WriteOptionFlag_WriteOptionFlag_Flush: root::nn::fs::WriteOptionFlag = 1;
            pub type WriteOptionFlag = u32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WriteOption {
                pub flags: libc::c_int,
            }
            #[test]
            fn bindgen_test_layout_WriteOption() {
                assert_eq!(
                    ::core::mem::size_of::<WriteOption>(),
                    4usize,
                    concat!("Size of: ", stringify!(WriteOption))
                );
                assert_eq!(
                    ::core::mem::align_of::<WriteOption>(),
                    4usize,
                    concat!("Alignment of ", stringify!(WriteOption))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<WriteOption>())).flags as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(WriteOption),
                        "::",
                        stringify!(flags)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs22QueryMountRomCacheSizeEPm"]
                pub fn QueryMountRomCacheSize(size: *mut u64) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs22QueryMountRomCacheSizeEPmm"]
                pub fn QueryMountRomCacheSize1(
                    size: *mut u64,
                    arg1: root::nn::ApplicationId,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs8MountRomEPKcPvm"]
                pub fn MountRom(
                    name: *const libc::c_char,
                    buffer: *mut libc::c_void,
                    bufferSize: root::ulong,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs19CanMountRomForDebugEv"]
                pub fn CanMountRomForDebug() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs11CanMountRomEm"]
                pub fn CanMountRom(arg1: root::nn::ApplicationId) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs28QueryMountRomOnFileCacheSizeEPmNS0_10FileHandleE"]
                pub fn QueryMountRomOnFileCacheSize(
                    arg1: *mut u64,
                    arg2: root::nn::fs::FileHandle,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs14MountRomOnFileEPKcNS0_10FileHandleEPvm"]
                pub fn MountRomOnFile(
                    arg1: *const libc::c_char,
                    arg2: root::nn::fs::FileHandle,
                    arg3: *mut libc::c_void,
                    arg4: u64,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs14EnsureSaveDataERKNS_7account3UidE"]
                pub fn EnsureSaveData(arg1: *const root::nn::account::Uid) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs13MountSaveDataEPKcm"]
                pub fn MountSaveData(
                    arg1: *const libc::c_char,
                    arg2: root::nn::fs::UserId,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs12GetEntryTypeEPNS0_18DirectoryEntryTypeEPKc"]
                pub fn GetEntryType(
                    type_: *mut root::nn::fs::DirectoryEntryType,
                    path: *const libc::c_char,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs10CreateFileEPKcl"]
                pub fn CreateFile(filepath: *const libc::c_char, size: root::s64) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs8OpenFileEPNS0_10FileHandleEPKci"]
                pub fn OpenFile(
                    arg1: *mut root::nn::fs::FileHandle,
                    path: *const libc::c_char,
                    arg2: root::s32,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs11SetFileSizeENS0_10FileHandleEl"]
                pub fn SetFileSize(
                    fileHandle: root::nn::fs::FileHandle,
                    filesize: root::s64,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs9CloseFileENS0_10FileHandleE"]
                pub fn CloseFile(fileHandle: root::nn::fs::FileHandle);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs9FlushFileENS0_10FileHandleE"]
                pub fn FlushFile(fileHandle: root::nn::fs::FileHandle) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs10DeleteFileEPKc"]
                pub fn DeleteFile(filepath: *const libc::c_char) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs15DeleteDirectoryEPKc"]
                pub fn DeleteDirectory(path: *const libc::c_char) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs26DeleteDirectoryRecursivelyEPKc"]
                pub fn DeleteDirectoryRecursively(path: *const libc::c_char) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs10RenameFileEPKcS2_"]
                pub fn RenameFile(
                    old: *const libc::c_char,
                    new: *const libc::c_char,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs15RenameDirectoryEPKcS2_"]
                pub fn RenameDirectory(
                    old: *const libc::c_char,
                    new: *const libc::c_char,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs8ReadFileEPmNS0_10FileHandleElPvmRKi"]
                pub fn ReadFile(
                    outSize: *mut u64,
                    handle: root::nn::fs::FileHandle,
                    offset: root::s64,
                    buffer: *mut libc::c_void,
                    bufferSize: u64,
                    arg1: *const root::s32,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs8ReadFileEPmNS0_10FileHandleElPvm"]
                pub fn ReadFile1(
                    outSize: *mut u64,
                    handle: root::nn::fs::FileHandle,
                    offset: root::s64,
                    buffer: *mut libc::c_void,
                    bufferSize: u64,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs8ReadFileENS0_10FileHandleElPvm"]
                pub fn ReadFile2(
                    handle: root::nn::fs::FileHandle,
                    offset: root::s64,
                    buffer: *mut libc::c_void,
                    bufferSize: u64,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs9WriteFileENS0_10FileHandleElPKvmRKNS0_11WriteOptionE"]
                pub fn WriteFile(
                    handle: root::nn::fs::FileHandle,
                    fileOffset: root::s64,
                    buff: *const libc::c_void,
                    size: u64,
                    option: *const root::nn::fs::WriteOption,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs11GetFileSizeEPlNS0_10FileHandleE"]
                pub fn GetFileSize(
                    size: *mut root::s64,
                    fileHandle: root::nn::fs::FileHandle,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs13OpenDirectoryEPNS0_15DirectoryHandleEPKci"]
                pub fn OpenDirectory(
                    handle: *mut root::nn::fs::DirectoryHandle,
                    path: *const libc::c_char,
                    openMode: root::s32,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs14CloseDirectoryENS0_15DirectoryHandleE"]
                pub fn CloseDirectory(directoryHandle: root::nn::fs::DirectoryHandle);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs13ReadDirectoryEPlPNS0_14DirectoryEntryENS0_15DirectoryHandleEl"]
                pub fn ReadDirectory(
                    arg1: *mut root::s64,
                    arg2: *mut root::nn::fs::DirectoryEntry,
                    directoryHandle: root::nn::fs::DirectoryHandle,
                    arg3: root::s64,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs15CreateDirectoryEPKc"]
                pub fn CreateDirectory(directorypath: *const libc::c_char) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs22GetDirectoryEntryCountEPlNS0_15DirectoryHandleE"]
                pub fn GetDirectoryEntryCount(
                    arg1: *mut root::s64,
                    arg2: root::nn::fs::DirectoryHandle,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs11MountSdCardEPKc"]
                pub fn MountSdCard(arg1: *const libc::c_char) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs19MountSdCardForDebugEPKc"]
                pub fn MountSdCardForDebug(arg1: *const libc::c_char) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs16IsSdCardInsertedEv"]
                pub fn IsSdCardInserted() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs12FormatSdCardEv"]
                pub fn FormatSdCard() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs18FormatSdCardDryRunEv"]
                pub fn FormatSdCardDryRun() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs16IsExFatSupportedEv"]
                pub fn IsExFatSupported() -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone)]
            pub struct FileTimeStamp {
                pub create: root::nn::time::PosixTime,
                pub modify: root::nn::time::PosixTime,
                pub access: root::nn::time::PosixTime,
                pub local_time: bool,
                padding: [u8;7],
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2fs24GetFileTimeStampForDebugEPNS0_13FileTimeStampEPKc"]
                pub fn GetFileTimeStampForDebug(out_timestamp: *mut FileTimeStamp, filepath: *const libc::c_char) -> root::Result;
            }
        }
        pub mod ro {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct Module {
                pub ModuleObject: *mut root::rtld::ModuleObject,
                pub State: u32,
                pub NroPtr: *mut libc::c_void,
                pub BssPtr: *mut libc::c_void,
                pub _x20: *mut libc::c_void,
                pub SourceBuffer: *mut libc::c_void,
                pub Name: [libc::c_char; 256usize],
                pub _x130: u8,
                pub _x131: u8,
                pub isLoaded: bool,
            }
            #[test]
            fn bindgen_test_layout_Module() {
                assert_eq!(
                    ::core::mem::size_of::<Module>(),
                    312usize,
                    concat!("Size of: ", stringify!(Module))
                );
                assert_eq!(
                    ::core::mem::align_of::<Module>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Module))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<Module>())).ModuleObject as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(ModuleObject)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>())).State as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(State)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>())).NroPtr as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(NroPtr)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>())).BssPtr as *const _ as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(BssPtr)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>()))._x20 as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(_x20)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<Module>())).SourceBuffer as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(SourceBuffer)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>())).Name as *const _ as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(Name)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>()))._x130 as *const _ as usize },
                    304usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(_x130)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>()))._x131 as *const _ as usize },
                    305usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(_x131)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Module>())).isLoaded as *const _ as usize },
                    306usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Module),
                        "::",
                        stringify!(isLoaded)
                    )
                );
            }
            #[repr(C)]
            pub struct ModuleId {
                pub build_id: [u8; 32usize],
            }
            #[test]
            fn bindgen_test_layout_ModuleId() {
                assert_eq!(
                    ::core::mem::size_of::<ModuleId>(),
                    32usize,
                    concat!("Size of: ", stringify!(ModuleId))
                );
                assert_eq!(
                    ::core::mem::align_of::<ModuleId>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ModuleId))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ModuleId>())).build_id as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ModuleId),
                        "::",
                        stringify!(build_id)
                    )
                );
            }
            #[repr(C)]
            pub struct NroHeader {
                pub entrypoint_insn: u32,
                pub mod_offset: u32,
                pub _x8: [u8; 8usize],
                pub magic: u32,
                pub _x14: [u8; 4usize],
                pub size: u32,
                pub reserved_1C: [u8; 4usize],
                pub text_offset: u32,
                pub text_size: u32,
                pub ro_offset: u32,
                pub ro_size: u32,
                pub rw_offset: u32,
                pub rw_size: u32,
                pub bss_size: u32,
                pub _x3C: [u8; 4usize],
                pub module_id: root::nn::ro::ModuleId,
                pub _x60: [u8; 32usize],
            }
            #[test]
            fn bindgen_test_layout_NroHeader() {
                assert_eq!(
                    ::core::mem::size_of::<NroHeader>(),
                    128usize,
                    concat!("Size of: ", stringify!(NroHeader))
                );
                assert_eq!(
                    ::core::mem::align_of::<NroHeader>(),
                    4usize,
                    concat!("Alignment of ", stringify!(NroHeader))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).entrypoint_insn as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(entrypoint_insn)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).mod_offset as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(mod_offset)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>()))._x8 as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(_x8)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>())).magic as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(magic)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>()))._x14 as *const _ as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(_x14)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>())).size as *const _ as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(size)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).reserved_1C as *const _ as usize
                    },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(reserved_1C)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).text_offset as *const _ as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(text_offset)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).text_size as *const _ as usize
                    },
                    36usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(text_size)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).ro_offset as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(ro_offset)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>())).ro_size as *const _ as usize },
                    44usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(ro_size)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).rw_offset as *const _ as usize
                    },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(rw_offset)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>())).rw_size as *const _ as usize },
                    52usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(rw_size)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>())).bss_size as *const _ as usize },
                    56usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(bss_size)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>()))._x3C as *const _ as usize },
                    60usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(_x3C)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NroHeader>())).module_id as *const _ as usize
                    },
                    64usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(module_id)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NroHeader>()))._x60 as *const _ as usize },
                    96usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NroHeader),
                        "::",
                        stringify!(_x60)
                    )
                );
            }
            #[repr(C)]
            pub struct ProgramId {
                pub value: u64,
            }
            #[test]
            fn bindgen_test_layout_ProgramId() {
                assert_eq!(
                    ::core::mem::size_of::<ProgramId>(),
                    8usize,
                    concat!("Size of: ", stringify!(ProgramId))
                );
                assert_eq!(
                    ::core::mem::align_of::<ProgramId>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ProgramId))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ProgramId>())).value as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ProgramId),
                        "::",
                        stringify!(value)
                    )
                );
            }
            #[repr(C)]
            pub struct NrrHeader {
                pub magic: u32,
                pub _x4: [u8; 12usize],
                pub program_id_mask: u64,
                pub program_id_pattern: u64,
                pub _x20: [u8; 16usize],
                pub modulus: [u8; 256usize],
                pub fixed_key_signature: [u8; 256usize],
                pub nrr_signature: [u8; 256usize],
                pub program_id: root::nn::ro::ProgramId,
                pub size: u32,
                pub type_: u8,
                pub _x33D: [u8; 3usize],
                pub hashes_offset: u32,
                pub num_hashes: u32,
                pub _x348: [u8; 8usize],
            }
            #[test]
            fn bindgen_test_layout_NrrHeader() {
                assert_eq!(
                    ::core::mem::size_of::<NrrHeader>(),
                    848usize,
                    concat!("Size of: ", stringify!(NrrHeader))
                );
                assert_eq!(
                    ::core::mem::align_of::<NrrHeader>(),
                    8usize,
                    concat!("Alignment of ", stringify!(NrrHeader))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>())).magic as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(magic)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>()))._x4 as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(_x4)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NrrHeader>())).program_id_mask as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(program_id_mask)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NrrHeader>())).program_id_pattern as *const _
                            as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(program_id_pattern)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>()))._x20 as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(_x20)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>())).modulus as *const _ as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(modulus)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NrrHeader>())).fixed_key_signature as *const _
                            as usize
                    },
                    304usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(fixed_key_signature)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NrrHeader>())).nrr_signature as *const _ as usize
                    },
                    560usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(nrr_signature)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NrrHeader>())).program_id as *const _ as usize
                    },
                    816usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(program_id)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>())).size as *const _ as usize },
                    824usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(size)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>())).type_ as *const _ as usize },
                    828usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(type_)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>()))._x33D as *const _ as usize },
                    829usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(_x33D)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NrrHeader>())).hashes_offset as *const _ as usize
                    },
                    832usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(hashes_offset)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<NrrHeader>())).num_hashes as *const _ as usize
                    },
                    836usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(num_hashes)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<NrrHeader>()))._x348 as *const _ as usize },
                    840usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(NrrHeader),
                        "::",
                        stringify!(_x348)
                    )
                );
            }
            #[repr(C)]
            pub struct RegistrationInfo {
                pub state: root::nn::ro::RegistrationInfo_State,
                pub nrrPtr: *mut root::nn::ro::NrrHeader,
                pub _x10: u64,
                pub _x18: u64,
            }
            pub const RegistrationInfo_State_State_Unregistered:
                root::nn::ro::RegistrationInfo_State = 0;
            pub const RegistrationInfo_State_State_Registered:
                root::nn::ro::RegistrationInfo_State = 1;
            pub type RegistrationInfo_State = u32;
            #[test]
            fn bindgen_test_layout_RegistrationInfo() {
                assert_eq!(
                    ::core::mem::size_of::<RegistrationInfo>(),
                    32usize,
                    concat!("Size of: ", stringify!(RegistrationInfo))
                );
                assert_eq!(
                    ::core::mem::align_of::<RegistrationInfo>(),
                    8usize,
                    concat!("Alignment of ", stringify!(RegistrationInfo))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<RegistrationInfo>())).state as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RegistrationInfo),
                        "::",
                        stringify!(state)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<RegistrationInfo>())).nrrPtr as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RegistrationInfo),
                        "::",
                        stringify!(nrrPtr)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<RegistrationInfo>()))._x10 as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RegistrationInfo),
                        "::",
                        stringify!(_x10)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<RegistrationInfo>()))._x18 as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RegistrationInfo),
                        "::",
                        stringify!(_x18)
                    )
                );
            }
            pub const BindFlag_BindFlag_Now: root::nn::ro::BindFlag = 1;
            pub const BindFlag_BindFlag_Lazy: root::nn::ro::BindFlag = 2;
            pub type BindFlag = u32;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro10InitializeEv"]
                pub fn Initialize() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro12LookupSymbolEPmPKc"]
                pub fn LookupSymbol(
                    pOutAddress: *mut usize,
                    name: *const libc::c_char,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro18LookupModuleSymbolEPmPKNS0_6ModuleEPKc"]
                pub fn LookupModuleSymbol(
                    pOutAddress: *mut usize,
                    pModule: *const root::nn::ro::Module,
                    name: *const libc::c_char,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro10LoadModuleEPNS0_6ModuleEPKvPvmi"]
                pub fn LoadModule(
                    pOutModule: *mut root::nn::ro::Module,
                    pImage: *const libc::c_void,
                    buffer: *mut libc::c_void,
                    bufferSize: root::size_t,
                    flag: libc::c_int,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro12UnloadModuleEPNS0_6ModuleE"]
                pub fn UnloadModule(arg1: *mut root::nn::ro::Module) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro13GetBufferSizeEPmPKv"]
                pub fn GetBufferSize(
                    arg1: *mut root::size_t,
                    arg2: *const libc::c_void,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro18RegisterModuleInfoEPNS0_16RegistrationInfoEPKv"]
                pub fn RegisterModuleInfo(
                    arg1: *mut root::nn::ro::RegistrationInfo,
                    arg2: *const libc::c_void,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro18RegisterModuleInfoEPNS0_16RegistrationInfoEPKvj"]
                pub fn RegisterModuleInfo1(
                    arg1: *mut root::nn::ro::RegistrationInfo,
                    arg2: *const libc::c_void,
                    arg3: root::uint,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2ro20UnregisterModuleInfoEPNS0_16RegistrationInfoE"]
                pub fn UnregisterModuleInfo(
                    arg1: *mut root::nn::ro::RegistrationInfo
                ) -> root::Result;
            }
        }
        pub mod crypto {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6crypto18GenerateSha256HashEPvmPKvm"]
                pub fn GenerateSha256Hash(
                    arg1: *mut libc::c_void,
                    arg2: root::ulong,
                    arg3: *const libc::c_void,
                    arg4: root::ulong,
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Sha256Context {
                _unused: [u8; 0],
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6crypto16DecryptAes128CbcEPvmPKvmS3_mS3_m"]
                pub fn DecryptAes128Cbc(
                    arg1: *mut libc::c_void,
                    arg2: u64,
                    arg3: *const libc::c_void,
                    arg4: u64,
                    arg5: *const libc::c_void,
                    arg6: u64,
                    arg7: *const libc::c_void,
                    arg8: u64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6crypto16EncryptAes128CbcEPvmPKvmS3_mS3_m"]
                pub fn EncryptAes128Cbc(
                    arg1: *mut libc::c_void,
                    arg2: u64,
                    arg3: *const libc::c_void,
                    arg4: u64,
                    arg5: *const libc::c_void,
                    arg6: u64,
                    arg7: *const libc::c_void,
                    arg8: u64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6crypto16DecryptAes128CcmEPvmS1_mPKvmS3_mS3_mS3_mm"]
                pub fn DecryptAes128Ccm(
                    arg1: *mut libc::c_void,
                    arg2: u64,
                    arg3: *mut libc::c_void,
                    arg4: u64,
                    arg5: *const libc::c_void,
                    arg6: u64,
                    arg7: *const libc::c_void,
                    arg8: u64,
                    arg9: *const libc::c_void,
                    arg10: u64,
                    arg11: *const libc::c_void,
                    arg12: u64,
                    arg13: u64,
                );
            }
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                pub struct Md5Impl {
                    pub _x0: u32,
                    pub _x4: u32,
                    pub _x8: u32,
                    pub _xC: u32,
                    pub _x10: [u8; 64usize],
                    pub _x50: u64,
                    pub _x58: u32,
                }
                #[test]
                fn bindgen_test_layout_Md5Impl() {
                    assert_eq!(
                        ::core::mem::size_of::<Md5Impl>(),
                        96usize,
                        concat!("Size of: ", stringify!(Md5Impl))
                    );
                    assert_eq!(
                        ::core::mem::align_of::<Md5Impl>(),
                        8usize,
                        concat!("Alignment of ", stringify!(Md5Impl))
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Md5Impl>()))._x0 as *const _ as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Md5Impl),
                            "::",
                            stringify!(_x0)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Md5Impl>()))._x4 as *const _ as usize },
                        4usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Md5Impl),
                            "::",
                            stringify!(_x4)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Md5Impl>()))._x8 as *const _ as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Md5Impl),
                            "::",
                            stringify!(_x8)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Md5Impl>()))._xC as *const _ as usize },
                        12usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Md5Impl),
                            "::",
                            stringify!(_xC)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Md5Impl>()))._x10 as *const _ as usize },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Md5Impl),
                            "::",
                            stringify!(_x10)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Md5Impl>()))._x50 as *const _ as usize },
                        80usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Md5Impl),
                            "::",
                            stringify!(_x50)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Md5Impl>()))._x58 as *const _ as usize },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Md5Impl),
                            "::",
                            stringify!(_x58)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail7Md5Impl10InitializeEv"]
                    pub fn Md5Impl_Initialize(this: *mut root::nn::crypto::detail::Md5Impl);
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail7Md5Impl6UpdateEPKvm"]
                    pub fn Md5Impl_Update(
                        this: *mut root::nn::crypto::detail::Md5Impl,
                        arg1: *const libc::c_void,
                        dataSize: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail7Md5Impl12ProcessBlockEv"]
                    pub fn Md5Impl_ProcessBlock(this: *mut root::nn::crypto::detail::Md5Impl);
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail7Md5Impl7GetHashEPvm"]
                    pub fn Md5Impl_GetHash(
                        this: *mut root::nn::crypto::detail::Md5Impl,
                        arg1: *mut libc::c_void,
                        hashSize: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail7Md5Impl16ProcessLastBlockEv"]
                    pub fn Md5Impl_ProcessLastBlock(this: *mut root::nn::crypto::detail::Md5Impl);
                }
                impl Md5Impl {
                    #[inline]
                    pub unsafe fn Initialize(&mut self) {
                        Md5Impl_Initialize(self)
                    }
                    #[inline]
                    pub unsafe fn Update(&mut self, arg1: *const libc::c_void, dataSize: u64) {
                        Md5Impl_Update(self, arg1, dataSize)
                    }
                    #[inline]
                    pub unsafe fn ProcessBlock(&mut self) {
                        Md5Impl_ProcessBlock(self)
                    }
                    #[inline]
                    pub unsafe fn GetHash(&mut self, arg1: *mut libc::c_void, hashSize: u64) {
                        Md5Impl_GetHash(self, arg1, hashSize)
                    }
                    #[inline]
                    pub unsafe fn ProcessLastBlock(&mut self) {
                        Md5Impl_ProcessLastBlock(self)
                    }
                }
                #[repr(C)]
                #[repr(align(16))]
                pub struct Sha1Impl {
                    pub _x0: u64,
                    pub _x8: u64,
                    pub _x10: u32,
                    pub __bindgen_padding_0: u64,
                    pub _x14: u128,
                    pub _x24: u128,
                    pub _x34: u128,
                    pub _x44: u32,
                    pub _x48: u64,
                    pub _x50: u64,
                    pub _x58: u64,
                    pub _x60: u64,
                }
                #[test]
                fn bindgen_test_layout_Sha1Impl() {
                    assert_eq!(
                        ::core::mem::size_of::<Sha1Impl>(),
                        128usize,
                        concat!("Size of: ", stringify!(Sha1Impl))
                    );
                    assert_eq!(
                        ::core::mem::align_of::<Sha1Impl>(),
                        16usize,
                        concat!("Alignment of ", stringify!(Sha1Impl))
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x0 as *const _ as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x0)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x8 as *const _ as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x8)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x10 as *const _ as usize },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x10)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x14 as *const _ as usize },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x14)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x24 as *const _ as usize },
                        48usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x24)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x34 as *const _ as usize },
                        64usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x34)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x44 as *const _ as usize },
                        80usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x44)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x48 as *const _ as usize },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x48)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x50 as *const _ as usize },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x50)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x58 as *const _ as usize },
                        104usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x58)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha1Impl>()))._x60 as *const _ as usize },
                        112usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha1Impl),
                            "::",
                            stringify!(_x60)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail8Sha1Impl10InitializeEv"]
                    #[allow(improper_ctypes)]
                    pub fn Sha1Impl_Initialize(this: *mut root::nn::crypto::detail::Sha1Impl);
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail8Sha1Impl6UpdateEPKvm"]
                    #[allow(improper_ctypes)]
                    pub fn Sha1Impl_Update(
                        this: *mut root::nn::crypto::detail::Sha1Impl,
                        arg1: *const libc::c_void,
                        arg2: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail8Sha1Impl12ProcessBlockEPKv"]
                    #[allow(improper_ctypes)]
                    pub fn Sha1Impl_ProcessBlock(
                        this: *mut root::nn::crypto::detail::Sha1Impl,
                        arg1: *const libc::c_void,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail8Sha1Impl7GetHashEPvm"]
                    #[allow(improper_ctypes)]
                    pub fn Sha1Impl_GetHash(
                        this: *mut root::nn::crypto::detail::Sha1Impl,
                        destHash: *mut libc::c_void,
                        arg1: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail8Sha1Impl16ProcessLastBlockEv"]
                    #[allow(improper_ctypes)]
                    pub fn Sha1Impl_ProcessLastBlock(this: *mut root::nn::crypto::detail::Sha1Impl);
                }
                impl Sha1Impl {
                    #[inline]
                    pub unsafe fn Initialize(&mut self) {
                        Sha1Impl_Initialize(self)
                    }
                    #[inline]
                    pub unsafe fn Update(&mut self, arg1: *const libc::c_void, arg2: u64) {
                        Sha1Impl_Update(self, arg1, arg2)
                    }
                    #[inline]
                    pub unsafe fn ProcessBlock(&mut self, arg1: *const libc::c_void) {
                        Sha1Impl_ProcessBlock(self, arg1)
                    }
                    #[inline]
                    pub unsafe fn GetHash(&mut self, destHash: *mut libc::c_void, arg1: u64) {
                        Sha1Impl_GetHash(self, destHash, arg1)
                    }
                    #[inline]
                    pub unsafe fn ProcessLastBlock(&mut self) {
                        Sha1Impl_ProcessLastBlock(self)
                    }
                }
                #[repr(C)]
                #[repr(align(16))]
                pub struct Sha256Impl {
                    pub _x0: u64,
                    pub _x8: u64,
                    pub _x10: u32,
                    pub __bindgen_padding_0: u64,
                    pub _x14: u128,
                    pub _x24: u128,
                    pub _x34: u128,
                    pub _x44: u32,
                    pub _x48: u64,
                    pub _x50: u64,
                    pub _x58: u64,
                    pub _x60: u64,
                    pub _x68: u64,
                    pub _x70: u32,
                }
                #[test]
                fn bindgen_test_layout_Sha256Impl() {
                    assert_eq!(
                        ::core::mem::size_of::<Sha256Impl>(),
                        144usize,
                        concat!("Size of: ", stringify!(Sha256Impl))
                    );
                    assert_eq!(
                        ::core::mem::align_of::<Sha256Impl>(),
                        16usize,
                        concat!("Alignment of ", stringify!(Sha256Impl))
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha256Impl>()))._x0 as *const _ as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x0)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::core::ptr::null::<Sha256Impl>()))._x8 as *const _ as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x8)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x10 as *const _ as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x10)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x14 as *const _ as usize
                        },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x14)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x24 as *const _ as usize
                        },
                        48usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x24)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x34 as *const _ as usize
                        },
                        64usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x34)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x44 as *const _ as usize
                        },
                        80usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x44)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x48 as *const _ as usize
                        },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x48)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x50 as *const _ as usize
                        },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x50)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x58 as *const _ as usize
                        },
                        104usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x58)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x60 as *const _ as usize
                        },
                        112usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x60)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x68 as *const _ as usize
                        },
                        120usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x68)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::core::ptr::null::<Sha256Impl>()))._x70 as *const _ as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Sha256Impl),
                            "::",
                            stringify!(_x70)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail10Sha256Impl10InitializeEv"]
                    #[allow(improper_ctypes)]
                    pub fn Sha256Impl_Initialize(this: *mut root::nn::crypto::detail::Sha256Impl);
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail10Sha256Impl6UpdateEPKvm"]
                    #[allow(improper_ctypes)]
                    pub fn Sha256Impl_Update(
                        this: *mut root::nn::crypto::detail::Sha256Impl,
                        arg1: *const libc::c_void,
                        arg2: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail10Sha256Impl13ProcessBlocksEPKhm"]
                    #[allow(improper_ctypes)]
                    pub fn Sha256Impl_ProcessBlocks(
                        this: *mut root::nn::crypto::detail::Sha256Impl,
                        arg1: *const u8,
                        arg2: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail10Sha256Impl7GetHashEPvm"]
                    #[allow(improper_ctypes)]
                    pub fn Sha256Impl_GetHash(
                        this: *mut root::nn::crypto::detail::Sha256Impl,
                        destHash: *mut libc::c_void,
                        arg1: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail10Sha256Impl16ProcessLastBlockEv"]
                    #[allow(improper_ctypes)]
                    pub fn Sha256Impl_ProcessLastBlock(
                        this: *mut root::nn::crypto::detail::Sha256Impl,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn6crypto6detail10Sha256Impl21InitializeWithContextEPKNS0_13Sha256ContextE"]
                    #[allow(improper_ctypes)]
                    pub fn Sha256Impl_InitializeWithContext(
                        this: *mut root::nn::crypto::detail::Sha256Impl,
                        arg1: *const root::nn::crypto::Sha256Context,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK2nn6crypto6detail10Sha256Impl10GetContextEPNS0_13Sha256ContextE"]
                    #[allow(improper_ctypes)]
                    pub fn Sha256Impl_GetContext(
                        this: *const root::nn::crypto::detail::Sha256Impl,
                        arg1: *mut root::nn::crypto::Sha256Context,
                    );
                }
                impl Sha256Impl {
                    #[inline]
                    pub unsafe fn Initialize(&mut self) {
                        Sha256Impl_Initialize(self)
                    }
                    #[inline]
                    pub unsafe fn Update(&mut self, arg1: *const libc::c_void, arg2: u64) {
                        Sha256Impl_Update(self, arg1, arg2)
                    }
                    #[inline]
                    pub unsafe fn ProcessBlocks(&mut self, arg1: *const u8, arg2: u64) {
                        Sha256Impl_ProcessBlocks(self, arg1, arg2)
                    }
                    #[inline]
                    pub unsafe fn GetHash(&mut self, destHash: *mut libc::c_void, arg1: u64) {
                        Sha256Impl_GetHash(self, destHash, arg1)
                    }
                    #[inline]
                    pub unsafe fn ProcessLastBlock(&mut self) {
                        Sha256Impl_ProcessLastBlock(self)
                    }
                    #[inline]
                    pub unsafe fn InitializeWithContext(
                        &mut self,
                        arg1: *const root::nn::crypto::Sha256Context,
                    ) {
                        Sha256Impl_InitializeWithContext(self, arg1)
                    }
                    #[inline]
                    pub unsafe fn GetContext(&self, arg1: *mut root::nn::crypto::Sha256Context) {
                        Sha256Impl_GetContext(self, arg1)
                    }
                }
            }
        }
        pub mod prepo {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct PlayReport {
                pub m_EventName: [libc::c_char; 32usize],
                pub m_Buff: *mut libc::c_void,
                pub m_BuffLength: root::size_t,
                pub m_End: u64,
            }
            #[test]
            fn bindgen_test_layout_PlayReport() {
                assert_eq!(
                    ::core::mem::size_of::<PlayReport>(),
                    56usize,
                    concat!("Size of: ", stringify!(PlayReport))
                );
                assert_eq!(
                    ::core::mem::align_of::<PlayReport>(),
                    8usize,
                    concat!("Alignment of ", stringify!(PlayReport))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<PlayReport>())).m_EventName as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PlayReport),
                        "::",
                        stringify!(m_EventName)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<PlayReport>())).m_Buff as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PlayReport),
                        "::",
                        stringify!(m_Buff)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<PlayReport>())).m_BuffLength as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PlayReport),
                        "::",
                        stringify!(m_BuffLength)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<PlayReport>())).m_End as *const _ as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PlayReport),
                        "::",
                        stringify!(m_End)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReport10SetEventIdEPKc"]
                pub fn PlayReport_SetEventId(
                    this: *mut root::nn::prepo::PlayReport,
                    arg1: *const libc::c_char,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReport9SetBufferEv"]
                pub fn PlayReport_SetBuffer(this: *mut root::nn::prepo::PlayReport)
                    -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReport3AddEPKcl"]
                pub fn PlayReport_Add(
                    this: *mut root::nn::prepo::PlayReport,
                    arg1: *const libc::c_char,
                    arg2: libc::c_long,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReport3AddEPKcd"]
                pub fn PlayReport_Add1(
                    this: *mut root::nn::prepo::PlayReport,
                    arg1: *const libc::c_char,
                    arg2: f64,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReport3AddEPKcS3_"]
                pub fn PlayReport_Add2(
                    this: *mut root::nn::prepo::PlayReport,
                    arg1: *const libc::c_char,
                    arg2: *const libc::c_char,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReport4SaveEv"]
                pub fn PlayReport_Save(this: *mut root::nn::prepo::PlayReport) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReport4SaveERKNS_7account3UidE"]
                pub fn PlayReport_Save1(
                    this: *mut root::nn::prepo::PlayReport,
                    arg1: *const root::nn::account::Uid,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5prepo10PlayReportC1Ev"]
                pub fn PlayReport_PlayReport(this: *mut root::nn::prepo::PlayReport);
            }
            impl PlayReport {
                #[inline]
                pub unsafe fn SetEventId(&mut self, arg1: *const libc::c_char) -> root::Result {
                    PlayReport_SetEventId(self, arg1)
                }
                #[inline]
                pub unsafe fn SetBuffer(&mut self) -> root::Result {
                    PlayReport_SetBuffer(self)
                }
                #[inline]
                pub unsafe fn Add(
                    &mut self,
                    arg1: *const libc::c_char,
                    arg2: libc::c_long,
                ) -> root::Result {
                    PlayReport_Add(self, arg1, arg2)
                }
                #[inline]
                pub unsafe fn Add1(
                    &mut self,
                    arg1: *const libc::c_char,
                    arg2: f64,
                ) -> root::Result {
                    PlayReport_Add1(self, arg1, arg2)
                }
                #[inline]
                pub unsafe fn Add2(
                    &mut self,
                    arg1: *const libc::c_char,
                    arg2: *const libc::c_char,
                ) -> root::Result {
                    PlayReport_Add2(self, arg1, arg2)
                }
                #[inline]
                pub unsafe fn Save(&mut self) -> root::Result {
                    PlayReport_Save(self)
                }
                #[inline]
                pub unsafe fn Save1(
                    &mut self,
                    arg1: *const root::nn::account::Uid,
                ) -> root::Result {
                    PlayReport_Save1(self, arg1)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                    PlayReport_PlayReport(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
            }
        }
        pub mod vi {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Display {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Layer {
                _unused: [u8; 0],
            }
            pub const ScalingMode_None: root::nn::vi::ScalingMode = 0;
            pub const ScalingMode_Exact: root::nn::vi::ScalingMode = 1;
            pub const ScalingMode_FitLayer: root::nn::vi::ScalingMode = 2;
            pub const ScalingMode_ScaleAndCrop: root::nn::vi::ScalingMode = 3;
            pub const ScalingMode_PreserveAspectRatio: root::nn::vi::ScalingMode = 4;
            pub type ScalingMode = u32;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2vi10InitializeEv"]
                pub fn Initialize();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2vi18OpenDefaultDisplayEPPNS0_7DisplayE"]
                pub fn OpenDefaultDisplay(
                    out_Disp: *mut *mut root::nn::vi::Display,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2vi11CreateLayerEPNS0_5LayerEPNS0_7DisplayE"]
                pub fn CreateLayer(
                    out_Layer: *mut root::nn::vi::Layer,
                    disp: *mut root::nn::vi::Display,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2vi19SetLayerScalingModeEPNS0_5LayerENS0_11ScalingModeE"]
                pub fn SetLayerScalingMode(
                    layer: *mut root::nn::vi::Layer,
                    scalingMode: root::nn::vi::ScalingMode,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2vi20GetDisplayVsyncEventEPNS_2os15SystemEventTypeEPNS0_7DisplayE"]
                pub fn GetDisplayVsyncEvent(
                    arg1: *mut root::nn::os::SystemEventType,
                    arg2: *mut root::nn::vi::Display,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn2vi15GetNativeWindowEPPvPNS0_5LayerE"]
                pub fn GetNativeWindow(
                    window: *mut *mut libc::c_void,
                    arg1: *mut root::nn::vi::Layer,
                ) -> root::Result;
            }
        }pub mod web {
            #[allow(unused_imports)]
            use self::super::super::super::root;

            #[repr(C)]
            pub struct ShowOfflineHtmlPageArg {
                data: [u8; 0x2000],
            }
            #[repr(C)]
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum OfflineBootDisplayKind {
                Default,
                White,
                Black,
                Screenshot,
                BlurredScreenshot
            }
            #[repr(C)]
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum OfflineBackgroundKind {
                Default,
                Screenshot,
                BlurredScreenshot
            }
            #[repr(C)]
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum WebSessionBootMode {
                Default,
                InitiallyHidden
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web19ShowOfflineHtmlPageEPNS0_26OfflineHtmlPageReturnValueERKNS0_22ShowOfflineHtmlPageArgE"]
                pub fn ShowOfflineHtmlPage(
                    return_value: *mut OfflineHtmlPageReturnValue,
                    arg: *const ShowOfflineHtmlPageArg,
                ) -> u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArgC2EPKc"]
                pub fn ShowOfflineHtmlPageArg(
                    this: *mut ShowOfflineHtmlPageArg,
                    page_path: *const libc::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg21SetJsExtensionEnabledEb"]
                pub fn SetOfflineJsExtensionEnabled(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg16SetFooterEnabledEb"]
                pub fn SetOfflineFooterEnabled(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg17SetPointerEnabledEb"]
                pub fn SetOfflinePointerEnabled(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg25SetBootLoadingIconEnabledEb"]
                pub fn SetOfflineBootLoadingIconEnabled(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg18SetWebAudioEnabledEb"]
                pub fn SetOfflineWebAudioEnabled(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                /// On a scale of 0.0 to 4.0
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg22OverrideWebAudioVolumeEf"]
                pub fn OverrideOfflineWebAudioVolume(
                    this: *mut ShowOfflineHtmlPageArg,
                    volume: f32,
                );
            }
            extern "C" {
                /// On a scale of 0.0 to 4.0
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg24OverrideMediaAudioVolumeEf"]
                pub fn OverrideOfflineMediaAudioVolume(
                    this: *mut ShowOfflineHtmlPageArg,
                    volume: f32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg20SetBootAsMediaPlayerEb"]
                pub fn SetOfflineBootAsMediaPlayer(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg18SetPageFadeEnabledEb"]
                pub fn SetOfflinePageFadeEnabled(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg19SetPageCacheEnabledEb"]
                pub fn SetOfflinePageCacheEnabled(
                    this: *mut ShowOfflineHtmlPageArg,
                    enabled: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg18SetBootDisplayKindENS0_22OfflineBootDisplayKindE"]
                pub fn SetOfflineBootDisplayKind(
                    this: *mut ShowOfflineHtmlPageArg,
                    boot_display_kind: OfflineBootDisplayKind,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web22ShowOfflineHtmlPageArg17SetBackgroundKindERKNS0_21OfflineBackgroundKindE"]
                pub fn SetOfflineBackgroundKind(
                    this: *mut ShowOfflineHtmlPageArg,
                    background_kind: *const OfflineBackgroundKind,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web11SetBootModeEPNS0_22ShowOfflineHtmlPageArgENS0_18WebSessionBootModeE"]
                pub fn SetBootMode(webpage_arg: &ShowOfflineHtmlPageArg, mode: WebSessionBootMode);
            }
            impl ShowOfflineHtmlPageArg {
                #[cfg(not(feature = "rustc-dep-of-std"))]
                #[inline]
                pub fn new<T: AsRef<[u8]>>(page_path: T) -> Result<Self, core::str::Utf8Error> {
                    let mut path_bytes = page_path.as_ref().to_vec();

                    if path_bytes.len() > 3072 {
                        path_bytes.truncate(3071);
                    }

                    path_bytes.append(&mut "\0".as_bytes().to_vec());

                    unsafe {
                        let mut instance = ShowOfflineHtmlPageArg { data: [0; 0x2000] };
                        ShowOfflineHtmlPageArg(&mut instance, path_bytes.as_ptr());
                        Ok(instance)
                    }
                }

                pub fn set_background_kind(&mut self, kind: OfflineBackgroundKind) {
                    unsafe { SetOfflineBackgroundKind(self, &kind) }
                }

                pub fn set_boot_display_kind(&mut self, kind: OfflineBootDisplayKind) {
                    unsafe { SetOfflineBootDisplayKind(self, kind) }
                }

                pub fn display_footer(&mut self, enabled: bool) {
                    unsafe { SetOfflineFooterEnabled(self, enabled) }
                }

                pub fn enable_javascript(&mut self, enabled: bool) {
                    unsafe { SetOfflineJsExtensionEnabled(self, enabled) }
                }

                pub fn enable_pointer(&mut self, enabled: bool) {
                    unsafe { SetOfflinePointerEnabled(self, enabled) }
                }

                pub fn enable_boot_loading_icon(&mut self, enabled: bool) {
                    unsafe { SetOfflineBootLoadingIconEnabled(self, enabled) }
                }

                pub fn enable_web_audio(&mut self, enabled: bool) {
                    unsafe { SetOfflineWebAudioEnabled(self, enabled) }
                }
                
                pub fn set_boot_mode(&mut self, mode: WebSessionBootMode) {
                    unsafe { SetBootMode(self, mode) }
                }
            }
            #[repr(C)]
            pub struct OfflineHtmlPageReturnValue {
                exit_reason: u64,
                last_url: [u8;4096],
                last_url_size: u64,
            }
            #[repr(C)]
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum OfflineExitReason {
                ExitPressed = 0,
                BackPressed = 1,
                Requested = 2,
                LastUrl = 3,
                ErrorDialog = 7,
                Unexpected = 20,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3web26OfflineHtmlPageReturnValueC1Ev"]
                pub fn OfflineHtmlPageReturnValue(this: *mut OfflineHtmlPageReturnValue);
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn3web26OfflineHtmlPageReturnValue20GetOfflineExitReasonEv"]
                pub fn GetOfflineExitReason(this: *const OfflineHtmlPageReturnValue) -> OfflineExitReason;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn3web26OfflineHtmlPageReturnValue10GetLastUrlEv"]
                pub fn GetLastUrl(this: *const OfflineHtmlPageReturnValue) -> *const libc::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn3web26OfflineHtmlPageReturnValue14GetLastUrlSizeEv"]
                pub fn GetLastUrlSize(this: *const OfflineHtmlPageReturnValue) -> usize;
            }
            impl OfflineHtmlPageReturnValue {
                pub fn new() -> Self {
                    let mut instance = OfflineHtmlPageReturnValue {
                        exit_reason: 0,
                        last_url: [0;4096],
                        last_url_size: 0,
                    };

                    unsafe { OfflineHtmlPageReturnValue(&mut instance); }

                    instance
                }

                pub fn get_exit_reason(&self) -> OfflineExitReason {
                    unsafe { GetOfflineExitReason(self) }
                }

            }
            pub mod offlinewebsession {
                use self::super::super::super::root;
                use self::super::{ShowOfflineHtmlPageArg, OfflineHtmlPageReturnValue};
                #[repr(C)]
                #[derive(Debug)]
                pub struct OfflineWebSessionImpl {
                    // This should be edited to use a const usize instead, as the size varies between SDK version. Refer to GetWorkBufferSize to get the actual size.
                    pub x: [u8;0xd0],
                }
                #[repr(C)]
                #[derive(Debug)]
                pub struct OfflineWebSession {
                    pub inner_web_impl: *const OfflineWebSessionImpl,
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn3web17OfflineWebSession17GetWorkBufferSizeEv"]
                    pub fn GetWorkBufferSize() -> usize;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn3web17OfflineWebSession10InitializeEPvm"]
                    pub fn Initialize(session: *const OfflineWebSession, web_impl: *const OfflineWebSessionImpl);
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn3web17OfflineWebSession5StartEPPNS_2os15SystemEventTypeERKNS0_22ShowOfflineHtmlPageArgE"]
                    pub fn Start(session: &OfflineWebSession, system_evt: &&root::nn::os::SystemEventType, webpage_arg: &ShowOfflineHtmlPageArg);
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn3web17OfflineWebSession6AppearEv"]
                    pub fn Appear(session: &OfflineWebSession) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn3web17OfflineWebSession21TrySendContentMessageEPKcm"]
                    pub fn TrySendContentMessage(session: &OfflineWebSession, buffer: *const u8, buf_len: usize);
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn3web17OfflineWebSession24TryReceiveContentMessageEPmPcm"]
                    pub fn TryReceiveContentMessage(session: &OfflineWebSession, out_size: *mut usize, buffer: *const u8, buf_len: usize) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn3web17OfflineWebSession11WaitForExitEPNS0_26OfflineHtmlPageReturnValueE"]
                    pub fn WaitForExit(session: &OfflineWebSession, return_val: &OfflineHtmlPageReturnValue) -> root::Result;
                }
            }
        }
        pub mod image {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const JpegStatus_OK: root::nn::image::JpegStatus = 0;
            pub const JpegStatus_INVALID_FORMAT: root::nn::image::JpegStatus = -32;
            pub const JpegStatus_UNSUPPORTED_FORMAT: root::nn::image::JpegStatus = -33;
            pub const JpegStatus_OUT_OF_MEMORY: root::nn::image::JpegStatus = -64;
            pub type JpegStatus = i32;
            pub const PixelFormat_RGBA32: root::nn::image::PixelFormat = 0;
            pub const PixelFormat_RGB24: root::nn::image::PixelFormat = 1;
            pub type PixelFormat = u32;
            pub const ProcessStage_UNREGISTERED: root::nn::image::ProcessStage = 0;
            pub const ProcessStage_REGISTERED: root::nn::image::ProcessStage = 1;
            pub const ProcessStage_ANALYZED: root::nn::image::ProcessStage = 2;
            pub type ProcessStage = u32;
            #[repr(C)]
            pub struct Dimension {
                pub width: f32,
                pub height: f32,
            }
            #[test]
            fn bindgen_test_layout_Dimension() {
                assert_eq!(
                    ::core::mem::size_of::<Dimension>(),
                    8usize,
                    concat!("Size of: ", stringify!(Dimension))
                );
                assert_eq!(
                    ::core::mem::align_of::<Dimension>(),
                    4usize,
                    concat!("Alignment of ", stringify!(Dimension))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Dimension>())).width as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Dimension),
                        "::",
                        stringify!(width)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Dimension>())).height as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Dimension),
                        "::",
                        stringify!(height)
                    )
                );
            }
            #[repr(C)]
            pub struct JpegDecoder__bindgen_vtable(libc::c_void);
            #[repr(C)]
            pub struct JpegDecoder {
                pub vtable_: *const JpegDecoder__bindgen_vtable,
                pub mProcessStage: root::nn::image::ProcessStage,
                pub mData: *mut libc::c_void,
                pub mSize: root::s64,
                pub _18: root::s32,
                pub mFormat: root::nn::image::PixelFormat,
                pub mImgDimensions: root::nn::image::Dimension,
                pub _28: root::s64,
            }
            #[test]
            fn bindgen_test_layout_JpegDecoder() {
                assert_eq!(
                    ::core::mem::size_of::<JpegDecoder>(),
                    56usize,
                    concat!("Size of: ", stringify!(JpegDecoder))
                );
                assert_eq!(
                    ::core::mem::align_of::<JpegDecoder>(),
                    8usize,
                    concat!("Alignment of ", stringify!(JpegDecoder))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<JpegDecoder>())).mProcessStage as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(JpegDecoder),
                        "::",
                        stringify!(mProcessStage)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<JpegDecoder>())).mData as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(JpegDecoder),
                        "::",
                        stringify!(mData)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<JpegDecoder>())).mSize as *const _ as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(JpegDecoder),
                        "::",
                        stringify!(mSize)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<JpegDecoder>()))._18 as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(JpegDecoder),
                        "::",
                        stringify!(_18)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<JpegDecoder>())).mFormat as *const _ as usize
                    },
                    36usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(JpegDecoder),
                        "::",
                        stringify!(mFormat)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<JpegDecoder>())).mImgDimensions as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(JpegDecoder),
                        "::",
                        stringify!(mImgDimensions)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<JpegDecoder>()))._28 as *const _ as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(JpegDecoder),
                        "::",
                        stringify!(_28)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5image11JpegDecoder12SetImageDataEPKvm"]
                pub fn JpegDecoder_SetImageData(
                    this: *mut root::nn::image::JpegDecoder,
                    source: *const libc::c_void,
                    size: u64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5image11JpegDecoder7AnalyzeEv"]
                pub fn JpegDecoder_Analyze(
                    this: *mut root::nn::image::JpegDecoder,
                ) -> root::nn::image::JpegStatus;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn5image11JpegDecoder20GetAnalyzedDimensionEv"]
                pub fn JpegDecoder_GetAnalyzedDimension(
                    this: *const root::nn::image::JpegDecoder,
                ) -> root::nn::image::Dimension;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn5image11JpegDecoder25GetAnalyzedWorkBufferSizeEv"]
                pub fn JpegDecoder_GetAnalyzedWorkBufferSize(
                    this: *const root::nn::image::JpegDecoder,
                ) -> root::s64;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5image11JpegDecoder6DecodeEPvliS2_l"]
                pub fn JpegDecoder_Decode(
                    this: *mut root::nn::image::JpegDecoder,
                    out: *mut libc::c_void,
                    arg1: root::s64,
                    alignment: root::s32,
                    arg2: *mut libc::c_void,
                    arg3: root::s64,
                ) -> root::nn::image::JpegStatus;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5image11JpegDecoderC1Ev"]
                pub fn JpegDecoder_JpegDecoder(this: *mut root::nn::image::JpegDecoder);
            }
            impl JpegDecoder {
                #[inline]
                pub unsafe fn SetImageData(&mut self, source: *const libc::c_void, size: u64) {
                    JpegDecoder_SetImageData(self, source, size)
                }
                #[inline]
                pub unsafe fn Analyze(&mut self) -> root::nn::image::JpegStatus {
                    JpegDecoder_Analyze(self)
                }
                #[inline]
                pub unsafe fn GetAnalyzedDimension(&self) -> root::nn::image::Dimension {
                    JpegDecoder_GetAnalyzedDimension(self)
                }
                #[inline]
                pub unsafe fn GetAnalyzedWorkBufferSize(&self) -> root::s64 {
                    JpegDecoder_GetAnalyzedWorkBufferSize(self)
                }
                #[inline]
                pub unsafe fn Decode(
                    &mut self,
                    out: *mut libc::c_void,
                    arg1: root::s64,
                    alignment: root::s32,
                    arg2: *mut libc::c_void,
                    arg3: root::s64,
                ) -> root::nn::image::JpegStatus {
                    JpegDecoder_Decode(self, out, arg1, alignment, arg2, arg3)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                    JpegDecoder_JpegDecoder(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5image11JpegDecoderD1Ev"]
                pub fn JpegDecoder_JpegDecoder_destructor(this: *mut root::nn::image::JpegDecoder);
            }
        }
        pub mod friends {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type Url = [libc::c_char; 160usize];
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7friends10InitializeEv"]
                pub fn Initialize();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7friends14GetProfileListEPNS0_12AsyncContextEPNS0_7ProfileERKNS_7account3UidEPKmi"]
                pub fn GetProfileList(
                    context: *mut root::nn::friends::AsyncContext,
                    profiles: *mut root::nn::friends::Profile,
                    userID: *const root::nn::account::Uid,
                    accountIDs: *const root::nn::account::NetworkServiceAccountId,
                    numAccounts: root::s32,
                ) -> root::Result;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Profile {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_Profile() {
                assert_eq!(
                    ::core::mem::size_of::<Profile>(),
                    1usize,
                    concat!("Size of: ", stringify!(Profile))
                );
                assert_eq!(
                    ::core::mem::align_of::<Profile>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Profile))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn7friends7Profile12GetAccountIdEv"]
                pub fn Profile_GetAccountId(
                    this: *const root::nn::friends::Profile,
                ) -> root::nn::account::NetworkServiceAccountId;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn7friends7Profile11GetNicknameEv"]
                pub fn Profile_GetNickname(
                    this: *const root::nn::friends::Profile,
                ) -> *mut root::nn::account::Nickname;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn7friends7Profile7IsValidEv"]
                pub fn Profile_IsValid(this: *const root::nn::friends::Profile) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7friends7Profile18GetProfileImageUrlEPA160_ci"]
                pub fn Profile_GetProfileImageUrl(
                    this: *mut root::nn::friends::Profile,
                    arg1: *mut root::nn::friends::Url,
                    arg2: root::s32,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7friends7ProfileC1Ev"]
                pub fn Profile_Profile(this: *mut root::nn::friends::Profile);
            }
            impl Profile {
                #[inline]
                pub unsafe fn GetAccountId(&self) -> root::nn::account::NetworkServiceAccountId {
                    Profile_GetAccountId(self)
                }
                #[inline]
                pub unsafe fn GetNickname(&self) -> *mut root::nn::account::Nickname {
                    Profile_GetNickname(self)
                }
                #[inline]
                pub unsafe fn IsValid(&self) -> bool {
                    Profile_IsValid(self)
                }
                #[inline]
                pub unsafe fn GetProfileImageUrl(
                    &mut self,
                    arg1: *mut root::nn::friends::Url,
                    arg2: root::s32,
                ) -> root::Result {
                    Profile_GetProfileImageUrl(self, arg1, arg2)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                    Profile_Profile(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AsyncContext {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AsyncContext() {
                assert_eq!(
                    ::core::mem::size_of::<AsyncContext>(),
                    1usize,
                    concat!("Size of: ", stringify!(AsyncContext))
                );
                assert_eq!(
                    ::core::mem::align_of::<AsyncContext>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AsyncContext))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7friends12AsyncContext14GetSystemEventEPNS_2os11SystemEventE"]
                pub fn AsyncContext_GetSystemEvent(
                    this: *mut root::nn::friends::AsyncContext,
                    arg1: *mut root::nn::os::SystemEvent,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn7friends12AsyncContext9GetResultEv"]
                pub fn AsyncContext_GetResult(
                    this: *const root::nn::friends::AsyncContext,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7friends12AsyncContextC1Ev"]
                pub fn AsyncContext_AsyncContext(this: *mut root::nn::friends::AsyncContext);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn7friends12AsyncContextD1Ev"]
                pub fn AsyncContext_AsyncContext_destructor(
                    this: *mut root::nn::friends::AsyncContext,
                );
            }
            impl AsyncContext {
                #[inline]
                pub unsafe fn GetSystemEvent(
                    &mut self,
                    arg1: *mut root::nn::os::SystemEvent,
                ) -> root::Result {
                    AsyncContext_GetSystemEvent(self, arg1)
                }
                #[inline]
                pub unsafe fn GetResult(&self) -> root::Result {
                    AsyncContext_GetResult(self)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                    AsyncContext_AsyncContext(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    AsyncContext_AsyncContext_destructor(self)
                }
            }
        }
        pub mod diag {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LogMetaData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct ModuleInfo {
                pub mPath: *mut libc::c_char,
                pub mBaseAddr: u64,
                pub mSize: u64,
            }
            #[test]
            fn bindgen_test_layout_ModuleInfo() {
                assert_eq!(
                    ::core::mem::size_of::<ModuleInfo>(),
                    24usize,
                    concat!("Size of: ", stringify!(ModuleInfo))
                );
                assert_eq!(
                    ::core::mem::align_of::<ModuleInfo>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ModuleInfo))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ModuleInfo>())).mPath as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ModuleInfo),
                        "::",
                        stringify!(mPath)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ModuleInfo>())).mBaseAddr as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ModuleInfo),
                        "::",
                        stringify!(mBaseAddr)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<ModuleInfo>())).mSize as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ModuleInfo),
                        "::",
                        stringify!(mSize)
                    )
                );
            }
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn4diag6detail7LogImplERKNS0_11LogMetaDataEPKcz"]
                    pub fn LogImpl(
                        arg1: *const root::nn::diag::LogMetaData,
                        arg2: *const libc::c_char,
                        ...
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn4diag6detail9AbortImplEPKcS3_S3_i"]
                    pub fn AbortImpl(
                        arg1: *const libc::c_char,
                        arg2: *const libc::c_char,
                        arg3: *const libc::c_char,
                        arg4: root::s32,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn4diag6detail9AbortImplEPKcS3_S3_ij"]
                    pub fn AbortImpl1(
                        arg1: *const libc::c_char,
                        arg2: *const libc::c_char,
                        arg3: *const libc::c_char,
                        arg4: libc::c_int,
                        arg5: root::Result,
                    );
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4diag12GetBacktraceEPmi"]
                pub fn GetBacktrace(out_array: *mut *const u8, array_len: i32)
                    -> usize;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4diag12GetBacktraceEPmimmm"]
                pub fn GetBacktrace1(
                    out_array: *mut *const u8,
                    array_len: i32,
                    fp: *const u64,
                    sp: *const u64,
                    pc: *const u64
                ) -> usize;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4diag13GetSymbolNameEPcmm"]
                pub fn GetSymbolName(name: *mut libc::c_char, nameSize: u64, addr: u64)
                    -> *mut u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4diag40GetRequiredBufferSizeForGetAllModuleInfoEv"]
                pub fn GetRequiredBufferSizeForGetAllModuleInfo() -> u64;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4diag16GetAllModuleInfoEPPNS0_10ModuleInfoEPvm"]
                pub fn GetAllModuleInfo(
                    out: *mut *mut root::nn::diag::ModuleInfo,
                    buffer: *mut libc::c_void,
                    bufferSize: u64,
                ) -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4diag13GetSymbolSizeEm"]
                pub fn GetSymbolSize(addr: u64) -> u64;
            }
        }
        pub mod ssl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const CertificateFormat_PEM: root::nn::ssl::CertificateFormat = 1;
            pub const CertificateFormat_DER: root::nn::ssl::CertificateFormat = 2;
            pub type CertificateFormat = u32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Context {
                pub _address: u8,
            }
            pub const Context_SslVersion_Auto: root::nn::ssl::Context_SslVersion = 1;
            pub const Context_SslVersion_v10: root::nn::ssl::Context_SslVersion = 8;
            pub const Context_SslVersion_v11: root::nn::ssl::Context_SslVersion = 16;
            pub const Context_SslVersion_v12: root::nn::ssl::Context_SslVersion = 32;
            pub type Context_SslVersion = u32;
            #[test]
            fn bindgen_test_layout_Context() {
                assert_eq!(
                    ::core::mem::size_of::<Context>(),
                    1usize,
                    concat!("Size of: ", stringify!(Context))
                );
                assert_eq!(
                    ::core::mem::align_of::<Context>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Context))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3ssl7Context6CreateENS1_10SslVersionE"]
                pub fn Context_Create(
                    this: *mut root::nn::ssl::Context,
                    version: root::nn::ssl::Context_SslVersion,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3ssl7Context15ImportServerPkiEPmPKcjNS0_17CertificateFormatE"]
                pub fn Context_ImportServerPki(
                    this: *mut root::nn::ssl::Context,
                    arg1: *mut u64,
                    certData: *const libc::c_char,
                    certSize: u32,
                    certFormat: root::nn::ssl::CertificateFormat,
                ) -> root::Result;
            }
            impl Context {
                #[inline]
                pub unsafe fn Create(
                    &mut self,
                    version: root::nn::ssl::Context_SslVersion,
                ) -> root::Result {
                    Context_Create(self, version)
                }
                #[inline]
                pub unsafe fn ImportServerPki(
                    &mut self,
                    arg1: *mut u64,
                    certData: *const libc::c_char,
                    certSize: u32,
                    certFormat: root::nn::ssl::CertificateFormat,
                ) -> root::Result {
                    Context_ImportServerPki(self, arg1, certData, certSize, certFormat)
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3ssl10InitializeEv"]
                pub fn Initialize() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3ssl8FinalizeEv"]
                pub fn Finalize() -> root::Result;
            }
        }
        pub mod mem {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct StandardAllocator {
                pub mIsInitialized: bool,
                pub mIsEnabledThreadCache: bool,
                pub _2: u16,
                pub mAllocAddr: *mut u64,
            }
            #[test]
            fn bindgen_test_layout_StandardAllocator() {
                assert_eq!(
                    ::core::mem::size_of::<StandardAllocator>(),
                    16usize,
                    concat!("Size of: ", stringify!(StandardAllocator))
                );
                assert_eq!(
                    ::core::mem::align_of::<StandardAllocator>(),
                    8usize,
                    concat!("Alignment of ", stringify!(StandardAllocator))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<StandardAllocator>())).mIsInitialized as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StandardAllocator),
                        "::",
                        stringify!(mIsInitialized)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<StandardAllocator>())).mIsEnabledThreadCache
                            as *const _ as usize
                    },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StandardAllocator),
                        "::",
                        stringify!(mIsEnabledThreadCache)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<StandardAllocator>()))._2 as *const _ as usize
                    },
                    2usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StandardAllocator),
                        "::",
                        stringify!(_2)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<StandardAllocator>())).mAllocAddr as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StandardAllocator),
                        "::",
                        stringify!(mAllocAddr)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3mem17StandardAllocator10InitializeEPvm"]
                pub fn StandardAllocator_Initialize(
                    this: *mut root::nn::mem::StandardAllocator,
                    address: *mut libc::c_void,
                    size: u64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3mem17StandardAllocator8FinalizeEv"]
                pub fn StandardAllocator_Finalize(this: *mut root::nn::mem::StandardAllocator);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3mem17StandardAllocator10ReallocateEPvm"]
                pub fn StandardAllocator_Reallocate(
                    this: *mut root::nn::mem::StandardAllocator,
                    address: *mut libc::c_void,
                    newSize: u64,
                ) -> *mut libc::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3mem17StandardAllocator8AllocateEm"]
                pub fn StandardAllocator_Allocate(
                    this: *mut root::nn::mem::StandardAllocator,
                    size: u64,
                ) -> *mut libc::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3mem17StandardAllocator4FreeEPv"]
                pub fn StandardAllocator_Free(
                    this: *mut root::nn::mem::StandardAllocator,
                    address: *mut libc::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3mem17StandardAllocator4DumpEv"]
                pub fn StandardAllocator_Dump(this: *mut root::nn::mem::StandardAllocator);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3mem17StandardAllocatorC1Ev"]
                pub fn StandardAllocator_StandardAllocator(
                    this: *mut root::nn::mem::StandardAllocator,
                );
            }
            impl StandardAllocator {
                #[inline]
                pub unsafe fn Initialize(&mut self, address: *mut libc::c_void, size: u64) {
                    StandardAllocator_Initialize(self, address, size)
                }
                #[inline]
                pub unsafe fn Finalize(&mut self) {
                    StandardAllocator_Finalize(self)
                }
                #[inline]
                pub unsafe fn Reallocate(
                    &mut self,
                    address: *mut libc::c_void,
                    newSize: u64,
                ) -> *mut libc::c_void {
                    StandardAllocator_Reallocate(self, address, newSize)
                }
                #[inline]
                pub unsafe fn Allocate(&mut self, size: u64) -> *mut libc::c_void {
                    StandardAllocator_Allocate(self, size)
                }
                #[inline]
                pub unsafe fn Free(&mut self, address: *mut libc::c_void) {
                    StandardAllocator_Free(self, address)
                }
                #[inline]
                pub unsafe fn Dump(&mut self) {
                    StandardAllocator_Dump(self)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                    StandardAllocator_StandardAllocator(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
            }
        }
        pub mod init {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4init19InitializeAllocatorEPvm"]
                pub fn InitializeAllocator(addr: *mut libc::c_void, size: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4init12GetAllocatorEv"]
                pub fn GetAllocator() -> *mut root::nn::mem::StandardAllocator;
            }
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn4init6detail30DefaultAllocatorForThreadLocalEmm"]
                    pub fn DefaultAllocatorForThreadLocal(
                        arg1: u64,
                        arg2: u64,
                    ) -> *mut libc::c_void;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2nn4init6detail32DefaultDeallocatorForThreadLocalEPvm"]
                    pub fn DefaultDeallocatorForThreadLocal(
                        arg1: *mut libc::c_void,
                        arg2: u64,
                    ) -> *mut libc::c_void;
                }
            }
        }
        pub mod util {
            #[repr(simd)]
            pub struct Vector3f {
                pub x: f32,
                pub y: f32,
                pub z: f32
            }

            #[repr(simd)]
            pub struct Vector4f {
                pub x: f32,
                pub y: f32,
                pub z: f32,
                pub w: f32
            }
            
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct Unorm8x4 {
                pub elements: [u8; 4usize],
            }
            #[test]
            fn bindgen_test_layout_Unorm8x4() {
                assert_eq!(
                    ::core::mem::size_of::<Unorm8x4>(),
                    4usize,
                    concat!("Size of: ", stringify!(Unorm8x4))
                );
                assert_eq!(
                    ::core::mem::align_of::<Unorm8x4>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Unorm8x4))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Unorm8x4>())).elements as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Unorm8x4),
                        "::",
                        stringify!(elements)
                    )
                );
            }
            #[repr(C)]
            pub struct Color4u8 {
                pub r: u8,
                pub g: u8,
                pub b: u8,
                pub a: u8,
            }
            #[test]
            fn bindgen_test_layout_Color4u8() {
                assert_eq!(
                    ::core::mem::size_of::<Color4u8>(),
                    4usize,
                    concat!("Size of: ", stringify!(Color4u8))
                );
                assert_eq!(
                    ::core::mem::align_of::<Color4u8>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Color4u8))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Color4u8>())).r as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color4u8),
                        "::",
                        stringify!(r)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Color4u8>())).g as *const _ as usize },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color4u8),
                        "::",
                        stringify!(g)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Color4u8>())).b as *const _ as usize },
                    2usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color4u8),
                        "::",
                        stringify!(b)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Color4u8>())).a as *const _ as usize },
                    3usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color4u8),
                        "::",
                        stringify!(a)
                    )
                );
            }
            pub const CharacterEncodingResult_Success: root::nn::util::CharacterEncodingResult = 0;
            pub const CharacterEncodingResult_BadLength: root::nn::util::CharacterEncodingResult =
                1;
            pub const CharacterEncodingResult_InvalidFormat:
                root::nn::util::CharacterEncodingResult = 2;
            pub type CharacterEncodingResult = u32;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4util30PickOutCharacterFromUtf8StringEPcPPKc"]
                pub fn PickOutCharacterFromUtf8String(
                    arg1: *mut libc::c_char,
                    str: *mut *const libc::c_char,
                ) -> root::nn::util::CharacterEncodingResult;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4util27ConvertCharacterUtf8ToUtf32EPjPKc"]
                pub fn ConvertCharacterUtf8ToUtf32(
                    dest: *mut u32,
                    src: *const libc::c_char,
                ) -> root::nn::util::CharacterEncodingResult;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4util30ConvertStringUtf16NativeToUtf8EPciPKti"]
                pub fn ConvertStringUtf16NativeToUtf8(
                    arg1: *mut libc::c_char,
                    arg2: root::s32,
                    arg3: *const u16,
                    arg4: root::s32,
                ) -> root::nn::util::CharacterEncodingResult;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4util30ConvertStringUtf8ToUtf16NativeEPtiPKci"]
                pub fn ConvertStringUtf8ToUtf16Native(
                    arg1: *mut u16,
                    arg2: root::s32,
                    arg3: *const libc::c_char,
                    arg4: root::s32,
                ) -> root::nn::util::CharacterEncodingResult;
            }

            #[repr(C)]
            pub struct RelocationTable {
                pub mMagic: root::s32,
                pub mPosition: u32,
                pub mSectionCount: root::s32,
            }
            #[test]
            fn bindgen_test_layout_RelocationTable() {
                assert_eq!(
                    ::core::mem::size_of::<RelocationTable>(),
                    12usize,
                    concat!("Size of: ", stringify!(RelocationTable))
                );
                assert_eq!(
                    ::core::mem::align_of::<RelocationTable>(),
                    4usize,
                    concat!("Alignment of ", stringify!(RelocationTable))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<RelocationTable>())).mMagic as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RelocationTable),
                        "::",
                        stringify!(mMagic)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<RelocationTable>())).mPosition as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RelocationTable),
                        "::",
                        stringify!(mPosition)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<RelocationTable>())).mSectionCount as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RelocationTable),
                        "::",
                        stringify!(mSectionCount)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4util15RelocationTable8RelocateEv"]
                pub fn RelocationTable_Relocate(this: *mut root::nn::util::RelocationTable);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4util15RelocationTable10UnrelocateEv"]
                pub fn RelocationTable_Unrelocate(this: *mut root::nn::util::RelocationTable);
            }
            impl RelocationTable {
                #[inline]
                pub unsafe fn Relocate(&mut self) {
                    RelocationTable_Relocate(self)
                }
                #[inline]
                pub unsafe fn Unrelocate(&mut self) {
                    RelocationTable_Unrelocate(self)
                }
            }
            #[repr(C)]
            pub struct BinaryFileHeader {
                pub mMagic: root::s32,
                pub mSig: u32,
                pub mVerMicro: u8,
                pub mVerMinor: u8,
                pub mVerMajor: u16,
                pub mBOM: u16,
                pub mAlignment: u8,
                pub mTargetAddrSize: u8,
                pub mFileNameOffset: u32,
                pub mFlag: u16,
                pub mFirstBlockOffs: u16,
                pub mRelocationTableOffs: u32,
                pub mSize: u32,
            }
            #[test]
            fn bindgen_test_layout_BinaryFileHeader() {
                assert_eq!(
                    ::core::mem::size_of::<BinaryFileHeader>(),
                    32usize,
                    concat!("Size of: ", stringify!(BinaryFileHeader))
                );
                assert_eq!(
                    ::core::mem::align_of::<BinaryFileHeader>(),
                    4usize,
                    concat!("Alignment of ", stringify!(BinaryFileHeader))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mMagic as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mMagic)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mSig as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mSig)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mVerMicro as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mVerMicro)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mVerMinor as *const _ as usize
                    },
                    9usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mVerMinor)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mVerMajor as *const _ as usize
                    },
                    10usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mVerMajor)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mBOM as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mBOM)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mAlignment as *const _
                            as usize
                    },
                    14usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mAlignment)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mTargetAddrSize as *const _
                            as usize
                    },
                    15usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mTargetAddrSize)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mFileNameOffset as *const _
                            as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mFileNameOffset)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mFlag as *const _ as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mFlag)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mFirstBlockOffs as *const _
                            as usize
                    },
                    22usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mFirstBlockOffs)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mRelocationTableOffs
                            as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mRelocationTableOffs)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<BinaryFileHeader>())).mSize as *const _ as usize
                    },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BinaryFileHeader),
                        "::",
                        stringify!(mSize)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn4util16BinaryFileHeader7IsValidEliii"]
                pub fn BinaryFileHeader_IsValid(
                    this: *const root::nn::util::BinaryFileHeader,
                    packedSig: root::s64,
                    majorVer: root::s32,
                    minorVer: root::s32,
                    microVer: root::s32,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn4util16BinaryFileHeader11IsRelocatedEv"]
                pub fn BinaryFileHeader_IsRelocated(
                    this: *const root::nn::util::BinaryFileHeader,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK2nn4util16BinaryFileHeader15IsEndianReverseEv"]
                pub fn BinaryFileHeader_IsEndianReverse(
                    this: *const root::nn::util::BinaryFileHeader,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4util16BinaryFileHeader18GetRelocationTableEv"]
                pub fn BinaryFileHeader_GetRelocationTable(
                    this: *mut root::nn::util::BinaryFileHeader,
                ) -> *mut root::nn::util::RelocationTable;
            }
            impl BinaryFileHeader {
                #[inline]
                pub unsafe fn IsValid(
                    &self,
                    packedSig: root::s64,
                    majorVer: root::s32,
                    minorVer: root::s32,
                    microVer: root::s32,
                ) -> bool {
                    BinaryFileHeader_IsValid(self, packedSig, majorVer, minorVer, microVer)
                }
                #[inline]
                pub unsafe fn IsRelocated(&self) -> bool {
                    BinaryFileHeader_IsRelocated(self)
                }
                #[inline]
                pub unsafe fn IsEndianReverse(&self) -> bool {
                    BinaryFileHeader_IsEndianReverse(self)
                }
                #[inline]
                pub unsafe fn GetRelocationTable(
                    &mut self,
                ) -> *mut root::nn::util::RelocationTable {
                    BinaryFileHeader_GetRelocationTable(self)
                }
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2nn11ReferSymbolEPKv"]
            pub fn ReferSymbol(arg1: *const libc::c_void);
        }
        pub mod hid {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Default)]
            pub struct NpadHandheldState {
                pub updateCount: i64,
                pub Buttons: u64,
                pub LStickX: i32,
                pub LStickY: i32,
                pub RStickX: i32,
                pub RStickY: i32,
                pub Flags: u32,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NpadStyleTag {
                _unused: [u8; 0],
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NpadStyleSet {
                pub flags: u32,
            }

            // pub u32 NpadStyleFullKey = 0x1;
            // pub u32 NpadStyleHandheld = 0x2;
            // pub u32 NpadStyleJoyDual = 0x4;
            // pub u32 NpadStyleJoyLeft = 0x8;
            // pub u32 NpadStyleJoyRight = 0x10;

            #[repr(C)]
            pub struct ControllerSupportArg {
                pub mMinPlayerCount: u8,
                pub mMaxPlayerCount: u8,
                pub mTakeOverConnection: u8,
                pub mLeftJustify: bool,
                pub mPermitJoyconDual: bool,
                pub mSingleMode: bool,
                pub mUseColors: bool,
                pub mColors: [root::nn::util::Color4u8; 4usize],
                pub mUsingControllerNames: u8,
                pub mControllerNames: [[libc::c_char; 129usize]; 4usize],
            }
            #[test]
            fn bindgen_test_layout_ControllerSupportArg() {
                assert_eq!(
                    ::core::mem::size_of::<ControllerSupportArg>(),
                    540usize,
                    concat!("Size of: ", stringify!(ControllerSupportArg))
                );
                assert_eq!(
                    ::core::mem::align_of::<ControllerSupportArg>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ControllerSupportArg))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mMinPlayerCount
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mMinPlayerCount)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mMaxPlayerCount
                            as *const _ as usize
                    },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mMaxPlayerCount)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mTakeOverConnection
                            as *const _ as usize
                    },
                    2usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mTakeOverConnection)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mLeftJustify as *const _
                            as usize
                    },
                    3usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mLeftJustify)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mPermitJoyconDual
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mPermitJoyconDual)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mSingleMode as *const _
                            as usize
                    },
                    5usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mSingleMode)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mUseColors as *const _
                            as usize
                    },
                    6usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mUseColors)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mColors as *const _
                            as usize
                    },
                    7usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mColors)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mUsingControllerNames
                            as *const _ as usize
                    },
                    23usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mUsingControllerNames)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportArg>())).mControllerNames
                            as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportArg),
                        "::",
                        stringify!(mControllerNames)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ControllerSupportResultInfo {
                pub mPlayerCount: libc::c_int,
                pub mSelectedId: libc::c_int,
            }
            #[test]
            fn bindgen_test_layout_ControllerSupportResultInfo() {
                assert_eq!(
                    ::core::mem::size_of::<ControllerSupportResultInfo>(),
                    8usize,
                    concat!("Size of: ", stringify!(ControllerSupportResultInfo))
                );
                assert_eq!(
                    ::core::mem::align_of::<ControllerSupportResultInfo>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ControllerSupportResultInfo))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportResultInfo>())).mPlayerCount
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportResultInfo),
                        "::",
                        stringify!(mPlayerCount)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<ControllerSupportResultInfo>())).mSelectedId
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ControllerSupportResultInfo),
                        "::",
                        stringify!(mSelectedId)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3hid14InitializeNpadEv"]
                pub fn InitializeNpad();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3hid22SetSupportedNpadIdTypeEPKjm"]
                pub fn SetSupportedNpadIdType(arg1: *const u32, arg2: u64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3hid24SetSupportedNpadStyleSetENS_4util10BitFlagSetILi32ENS0_12NpadStyleTagEEE"]
                pub fn SetSupportedNpadStyleSet(arg1: u8);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3hid15GetNpadStyleSetERKj"]
                pub fn GetNpadStyleSet(arg1: *const u32) -> NpadStyleSet;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3hid19GetPlayerLedPatternERKj"]
                pub fn GetPlayerLedPattern(arg1: *const u32);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3hid13GetNpadStatesEPNS0_17NpadHandheldStateEiRKj"]
                pub fn GetNpadStates(
                    arg1: *mut root::nn::hid::NpadHandheldState,
                    arg2: root::s32,
                    arg3: *const u32,
                );
            }

            extern "C" {
                #[link_name = "\u{1}_ZN2nn3hid12GetNpadStateEPNS0_17NpadHandheldStateERKj"]
                pub fn GetNpadHandheldState(arg1: *mut root::nn::hid::NpadHandheldState, arg2: *const u32);

                #[link_name = "\u{1}_ZN2nn3hid12GetNpadStateEPNS0_16NpadFullKeyStateERKj"]
                pub fn GetNpadFullKeyState(arg1: *mut root::nn::hid::NpadHandheldState, arg2: *const u32);

                #[link_name = "\u{1}_ZN2nn3hid12GetNpadStateEPNS0_11NpadGcStateERKj"]
                pub fn GetNpadGcState(arg1: *mut root::nn::hid::NpadHandheldState, arg2: *const u32);

                #[link_name = "\u{1}_ZN2nn3hid12GetNpadStateEPNS0_16NpadJoyDualStateERKj"]
                pub fn GetNpadJoyDualState(arg1: *mut root::nn::hid::NpadHandheldState, arg2: *const u32);

                #[link_name = "\u{1}_ZN2nn3hid12GetNpadStateEPNS0_16NpadJoyLeftStateERKj"]
                pub fn GetNpadJoyLeftState(arg1: *mut root::nn::hid::NpadHandheldState, arg2: *const u32);

                #[link_name = "\u{1}_ZN2nn3hid12GetNpadStateEPNS0_17NpadJoyRightStateERKj"]
                pub fn GetNpadJoyRightState(arg1: *mut root::nn::hid::NpadHandheldState, arg2: *const u32);
            }
        }
        pub mod audio {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AudioRendererConfig {
                pub _0: *mut u64,
                pub _8: *mut u64,
                pub _10: *mut u64,
                pub _18: *mut u64,
                pub _20: *mut u64,
                pub _28: *mut u64,
                pub _30: *mut u64,
                pub _38: *mut u64,
                pub _40: *mut u64,
                pub _48: *mut u64,
                pub _50: *mut u64,
            }
            #[test]
            fn bindgen_test_layout_AudioRendererConfig() {
                assert_eq!(
                    ::core::mem::size_of::<AudioRendererConfig>(),
                    88usize,
                    concat!("Size of: ", stringify!(AudioRendererConfig))
                );
                assert_eq!(
                    ::core::mem::align_of::<AudioRendererConfig>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AudioRendererConfig))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._0 as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_0)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._8 as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_8)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._10 as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_10)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._18 as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_18)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._20 as *const _ as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_20)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._28 as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_28)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._30 as *const _ as usize
                    },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_30)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._38 as *const _ as usize
                    },
                    56usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_38)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._40 as *const _ as usize
                    },
                    64usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_40)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._48 as *const _ as usize
                    },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_48)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<AudioRendererConfig>()))._50 as *const _ as usize
                    },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AudioRendererConfig),
                        "::",
                        stringify!(_50)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DelayType {
                pub _0: *mut u64,
            }
            #[test]
            fn bindgen_test_layout_DelayType() {
                assert_eq!(
                    ::core::mem::size_of::<DelayType>(),
                    8usize,
                    concat!("Size of: ", stringify!(DelayType))
                );
                assert_eq!(
                    ::core::mem::align_of::<DelayType>(),
                    8usize,
                    concat!("Alignment of ", stringify!(DelayType))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<DelayType>()))._0 as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DelayType),
                        "::",
                        stringify!(_0)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FinalMixType {
                pub _0: *mut u64,
            }
            #[test]
            fn bindgen_test_layout_FinalMixType() {
                assert_eq!(
                    ::core::mem::size_of::<FinalMixType>(),
                    8usize,
                    concat!("Size of: ", stringify!(FinalMixType))
                );
                assert_eq!(
                    ::core::mem::align_of::<FinalMixType>(),
                    8usize,
                    concat!("Alignment of ", stringify!(FinalMixType))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<FinalMixType>()))._0 as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FinalMixType),
                        "::",
                        stringify!(_0)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SubMixType {
                pub _0: *mut u64,
            }
            #[test]
            fn bindgen_test_layout_SubMixType() {
                assert_eq!(
                    ::core::mem::size_of::<SubMixType>(),
                    8usize,
                    concat!("Size of: ", stringify!(SubMixType))
                );
                assert_eq!(
                    ::core::mem::align_of::<SubMixType>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SubMixType))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<SubMixType>()))._0 as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubMixType),
                        "::",
                        stringify!(_0)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5audio19SetDelayInputOutputEPNS0_9DelayTypeEPKaS4_i"]
                pub fn SetDelayInputOutput(
                    arg1: *mut root::nn::audio::DelayType,
                    arg2: *const root::s8,
                    arg3: *const root::s8,
                    arg4: root::s32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5audio11RemoveDelayEPNS0_19AudioRendererConfigEPNS0_9DelayTypeEPNS0_12FinalMixTypeE"]
                pub fn RemoveDelay(
                    arg1: *mut root::nn::audio::AudioRendererConfig,
                    arg2: *mut root::nn::audio::DelayType,
                    arg3: *mut root::nn::audio::FinalMixType,
                ) -> *mut libc::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5audio11RemoveDelayEPNS0_19AudioRendererConfigEPNS0_9DelayTypeEPNS0_10SubMixTypeE"]
                pub fn RemoveDelay1(
                    arg1: *mut root::nn::audio::AudioRendererConfig,
                    arg2: *mut root::nn::audio::DelayType,
                    arg3: *mut root::nn::audio::SubMixType,
                ) -> *mut libc::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn5audio17IsDelayRemoveableEPNS0_9DelayTypeE"]
                pub fn IsDelayRemoveable(arg1: *mut root::nn::audio::DelayType) -> bool;
            }
        }
        pub mod svc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct Handle {
                pub handle: u32,
            }
            #[test]
            fn bindgen_test_layout_Handle() {
                assert_eq!(
                    ::core::mem::size_of::<Handle>(),
                    4usize,
                    concat!("Size of: ", stringify!(Handle))
                );
                assert_eq!(
                    ::core::mem::align_of::<Handle>(),
                    4usize,
                    concat!("Alignment of ", stringify!(Handle))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<Handle>())).handle as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Handle),
                        "::",
                        stringify!(handle)
                    )
                );
            }
        }
        pub mod nifm {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm10InitializeEv"]
                pub fn Initialize() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm19SetLocalNetworkModeEb"]
                pub fn SetLocalNetworkMode(arg1: bool);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm27SubmitNetworkRequestAndWaitEv"]
                pub fn SubmitNetworkRequestAndWait();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm18IsNetworkAvailableEv"]
                pub fn IsNetworkAvailable() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm26HandleNetworkRequestResultEv"]
                pub fn HandleNetworkRequestResult() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm20SubmitNetworkRequestEv"]
                pub fn SubmitNetworkRequest();
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm22IsNetworkRequestOnHoldEv"]
                pub fn IsNetworkRequestOnHold() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn4nifm26GetCurrentPrimaryIpAddressEPm"]
                pub fn GetCurrentPrimaryIpAddress(inAddr: *mut u64) -> root::Result;
            }
        }
        pub mod ldn {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3ldn10InitializeEv"]
                pub fn Initialize() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn3ldn8FinalizeEv"]
                pub fn Finalize() -> root::Result;
            }
        }
        pub mod socket {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct InAddr {
                pub addr: u32,
            }
            #[test]
            fn bindgen_test_layout_InAddr() {
                assert_eq!(
                    ::core::mem::size_of::<InAddr>(),
                    4usize,
                    concat!("Size of: ", stringify!(InAddr))
                );
                assert_eq!(
                    ::core::mem::align_of::<InAddr>(),
                    4usize,
                    concat!("Alignment of ", stringify!(InAddr))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<InAddr>())).addr as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(InAddr),
                        "::",
                        stringify!(addr)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket10InitializeEPvmmi"]
                pub fn Initialize(
                    pool: *mut libc::c_void,
                    poolSize: root::ulong,
                    allocPoolSize: root::ulong,
                    concurLimit: libc::c_int,
                ) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket10InitializeERKNS0_6ConfigE"]
                pub fn Initialize_Config(config: *mut libc::c_void) -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket8FinalizeEv"]
                pub fn Finalize() -> root::Result;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket10SetSockOptEiiiPKvj"]
                pub fn SetSockOpt(
                    socket: root::s32,
                    socketLevel: root::s32,
                    option: root::s32,
                    arg1: *const libc::c_void,
                    len: u32,
                ) -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket4SendEiPKvmi"]
                pub fn Send(
                    socket: root::s32,
                    buffer: *const libc::c_void,
                    bufferLength: u64,
                    flags: root::s32,
                ) -> u64;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket6SocketEiii"]
                pub fn Socket(domain: root::s32, type_: root::s32, proto: root::s32) -> root::s32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket9InetHtonsEt"]
                pub fn InetHtons(arg1: u16) -> u16;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket8InetAtonEPKcPNS0_6InAddrE"]
                pub fn InetAton(
                    str: *const libc::c_char,
                    arg1: *mut root::nn::socket::InAddr,
                ) -> u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket7ConnectEiPK8sockaddrj"]
                pub fn Connect(socket: root::s32, addr: *const root::sockaddr, addrLen: u32)
                    -> u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket4BindEiPK8sockaddrj"]
                pub fn Bind(socket: root::s32, addr: *const root::sockaddr, addrLen: u32) -> u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket6ListenEii"]
                pub fn Listen(socket: root::s32, backlog: root::s32) -> u32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2nn6socket6AcceptEiP8sockaddrPj"]
                pub fn Accept(
                    socket: root::s32,
                    addrOut: *mut root::sockaddr,
                    addrLenOut: *mut u32,
                ) -> u32;
            }
        }
    }
    extern "C" {
        pub fn main(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int;
    }
    extern "C" {
        pub fn nninitStartup();
    }
    extern "C" {
        pub fn _init();
    }
    extern "C" {
        pub fn _fini();
    }
    extern "C" {
        pub fn __nnDetailNintendoSdkRuntimeObjectFileRefer();
    }
    extern "C" {
        pub fn __nnDetailNintendoSdkRuntimeObjectFile();
    }
    extern "C" {
        pub fn __nnDetailNintendoSdkNsoFileRefer();
    }
    extern "C" {
        pub fn __nnmusl_init_dso_0();
    }
    extern "C" {
        pub fn __nnmusl_fini_dso_0();
    }
    extern "C" {
        pub fn __nnDetailNintendoSdkNsoFile_0();
    }
    #[repr(C)]
    pub struct nnosMutexType {
        pub curState: u8,
        pub isRecursiveMutex: bool,
        pub lockLevel: root::s32,
        pub _6: [u8; 18usize],
    }
    #[test]
    fn bindgen_test_layout_nnosMutexType() {
        assert_eq!(
            ::core::mem::size_of::<nnosMutexType>(),
            28usize,
            concat!("Size of: ", stringify!(nnosMutexType))
        );
        assert_eq!(
            ::core::mem::align_of::<nnosMutexType>(),
            4usize,
            concat!("Alignment of ", stringify!(nnosMutexType))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nnosMutexType>())).curState as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nnosMutexType),
                "::",
                stringify!(curState)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nnosMutexType>())).isRecursiveMutex as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(nnosMutexType),
                "::",
                stringify!(isRecursiveMutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nnosMutexType>())).lockLevel as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(nnosMutexType),
                "::",
                stringify!(lockLevel)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nnosMutexType>()))._6 as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(nnosMutexType),
                "::",
                stringify!(_6)
            )
        );
    }
    extern "C" {
        pub fn nnosInitializeMutex(arg1: *mut root::nnosMutexType, arg2: bool, arg3: root::s32);
    }
    extern "C" {
        pub fn nnosFinalizeMutex(arg1: *mut root::nnosMutexType);
    }
    extern "C" {
        pub fn nnosLockMutex(arg1: *mut root::nnosMutexType);
    }
    extern "C" {
        pub fn nnosTryLockMutex(arg1: *mut root::nnosMutexType) -> bool;
    }
    extern "C" {
        pub fn nnosUnlockMutex(arg1: *mut root::nnosMutexType);
    }
    extern "C" {
        pub fn llabs(n: libc::c_longlong) -> libc::c_longlong;
    }
    extern "C" {
        pub fn __assert_fail(
            __assertion: *const libc::c_char,
            __file: *const libc::c_char,
            __line: libc::c_uint,
            __function: *const libc::c_char,
        );
    }
    extern "C" {
        pub fn __assert_perror_fail(
            __errnum: libc::c_int,
            __file: *const libc::c_char,
            __line: libc::c_uint,
            __function: *const libc::c_char,
        );
    }
    extern "C" {
        pub fn __assert(
            __assertion: *const libc::c_char,
            __file: *const libc::c_char,
            __line: libc::c_int,
        );
    }
    pub type Elf32_Half = u16;
    pub type Elf64_Half = u16;
    pub type Elf32_Word = u32;
    pub type Elf32_Sword = i32;
    pub type Elf64_Word = u32;
    pub type Elf64_Sword = i32;
    pub type Elf32_Xword = u64;
    pub type Elf32_Sxword = i64;
    pub type Elf64_Xword = u64;
    pub type Elf64_Sxword = i64;
    pub type Elf32_Addr = u32;
    pub type Elf64_Addr = u64;
    pub type Elf32_Off = u32;
    pub type Elf64_Off = u64;
    pub type Elf32_Section = u16;
    pub type Elf64_Section = u16;
    pub type Elf32_Versym = root::Elf32_Half;
    pub type Elf64_Versym = root::Elf64_Half;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Ehdr {
        pub e_ident: [libc::c_uchar; 16usize],
        pub e_type: root::Elf32_Half,
        pub e_machine: root::Elf32_Half,
        pub e_version: root::Elf32_Word,
        pub e_entry: root::Elf32_Addr,
        pub e_phoff: root::Elf32_Off,
        pub e_shoff: root::Elf32_Off,
        pub e_flags: root::Elf32_Word,
        pub e_ehsize: root::Elf32_Half,
        pub e_phentsize: root::Elf32_Half,
        pub e_phnum: root::Elf32_Half,
        pub e_shentsize: root::Elf32_Half,
        pub e_shnum: root::Elf32_Half,
        pub e_shstrndx: root::Elf32_Half,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Ehdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Ehdr>(),
            52usize,
            concat!("Size of: ", stringify!(Elf32_Ehdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Ehdr>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Ehdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_ident as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_ident)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_type as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_machine as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_machine)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_version as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_entry as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_phoff as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_phoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_shoff as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_shoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_flags as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_ehsize as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_ehsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_phentsize as *const _ as usize },
            42usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_phentsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_phnum as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_phnum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_shentsize as *const _ as usize },
            46usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_shentsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_shnum as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_shnum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Ehdr>())).e_shstrndx as *const _ as usize },
            50usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Ehdr),
                "::",
                stringify!(e_shstrndx)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Ehdr {
        pub e_ident: [libc::c_uchar; 16usize],
        pub e_type: root::Elf64_Half,
        pub e_machine: root::Elf64_Half,
        pub e_version: root::Elf64_Word,
        pub e_entry: root::Elf64_Addr,
        pub e_phoff: root::Elf64_Off,
        pub e_shoff: root::Elf64_Off,
        pub e_flags: root::Elf64_Word,
        pub e_ehsize: root::Elf64_Half,
        pub e_phentsize: root::Elf64_Half,
        pub e_phnum: root::Elf64_Half,
        pub e_shentsize: root::Elf64_Half,
        pub e_shnum: root::Elf64_Half,
        pub e_shstrndx: root::Elf64_Half,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Ehdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Ehdr>(),
            64usize,
            concat!("Size of: ", stringify!(Elf64_Ehdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Ehdr>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Ehdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_ident as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_ident)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_type as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_machine as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_machine)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_version as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_entry as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_phoff as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_phoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_shoff as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_shoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_flags as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_ehsize as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_ehsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_phentsize as *const _ as usize },
            54usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_phentsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_phnum as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_phnum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_shentsize as *const _ as usize },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_shentsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_shnum as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_shnum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Ehdr>())).e_shstrndx as *const _ as usize },
            62usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Ehdr),
                "::",
                stringify!(e_shstrndx)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Shdr {
        pub sh_name: root::Elf32_Word,
        pub sh_type: root::Elf32_Word,
        pub sh_flags: root::Elf32_Word,
        pub sh_addr: root::Elf32_Addr,
        pub sh_offset: root::Elf32_Off,
        pub sh_size: root::Elf32_Word,
        pub sh_link: root::Elf32_Word,
        pub sh_info: root::Elf32_Word,
        pub sh_addralign: root::Elf32_Word,
        pub sh_entsize: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Shdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Shdr>(),
            40usize,
            concat!("Size of: ", stringify!(Elf32_Shdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Shdr>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Shdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_type as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_addr as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_offset as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_size as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_link as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_link)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_info as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_addralign as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_addralign)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Shdr>())).sh_entsize as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Shdr),
                "::",
                stringify!(sh_entsize)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Shdr {
        pub sh_name: root::Elf64_Word,
        pub sh_type: root::Elf64_Word,
        pub sh_flags: root::Elf64_Xword,
        pub sh_addr: root::Elf64_Addr,
        pub sh_offset: root::Elf64_Off,
        pub sh_size: root::Elf64_Xword,
        pub sh_link: root::Elf64_Word,
        pub sh_info: root::Elf64_Word,
        pub sh_addralign: root::Elf64_Xword,
        pub sh_entsize: root::Elf64_Xword,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Shdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Shdr>(),
            64usize,
            concat!("Size of: ", stringify!(Elf64_Shdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Shdr>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Shdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_type as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_addr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_offset as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_size as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_link as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_link)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_info as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_addralign as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_addralign)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Shdr>())).sh_entsize as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Shdr),
                "::",
                stringify!(sh_entsize)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Chdr {
        pub ch_type: root::Elf32_Word,
        pub ch_size: root::Elf32_Word,
        pub ch_addralign: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Chdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Chdr>(),
            12usize,
            concat!("Size of: ", stringify!(Elf32_Chdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Chdr>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Chdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Chdr>())).ch_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Chdr),
                "::",
                stringify!(ch_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Chdr>())).ch_size as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Chdr),
                "::",
                stringify!(ch_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Chdr>())).ch_addralign as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Chdr),
                "::",
                stringify!(ch_addralign)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Chdr {
        pub ch_type: root::Elf64_Word,
        pub ch_reserved: root::Elf64_Word,
        pub ch_size: root::Elf64_Xword,
        pub ch_addralign: root::Elf64_Xword,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Chdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Chdr>(),
            24usize,
            concat!("Size of: ", stringify!(Elf64_Chdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Chdr>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Chdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Chdr>())).ch_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Chdr),
                "::",
                stringify!(ch_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Chdr>())).ch_reserved as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Chdr),
                "::",
                stringify!(ch_reserved)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Chdr>())).ch_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Chdr),
                "::",
                stringify!(ch_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Chdr>())).ch_addralign as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Chdr),
                "::",
                stringify!(ch_addralign)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Sym {
        pub st_name: root::Elf32_Word,
        pub st_value: root::Elf32_Addr,
        pub st_size: root::Elf32_Word,
        pub st_info: libc::c_uchar,
        pub st_other: libc::c_uchar,
        pub st_shndx: root::Elf32_Section,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Sym() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Sym>(),
            16usize,
            concat!("Size of: ", stringify!(Elf32_Sym))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Sym>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Sym))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Sym>())).st_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Sym),
                "::",
                stringify!(st_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Sym>())).st_value as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Sym),
                "::",
                stringify!(st_value)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Sym>())).st_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Sym),
                "::",
                stringify!(st_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Sym>())).st_info as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Sym),
                "::",
                stringify!(st_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Sym>())).st_other as *const _ as usize },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Sym),
                "::",
                stringify!(st_other)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Sym>())).st_shndx as *const _ as usize },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Sym),
                "::",
                stringify!(st_shndx)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Sym {
        pub st_name: root::Elf64_Word,
        pub st_info: libc::c_uchar,
        pub st_other: libc::c_uchar,
        pub st_shndx: root::Elf64_Section,
        pub st_value: root::Elf64_Addr,
        pub st_size: root::Elf64_Xword,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Sym() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Sym>(),
            24usize,
            concat!("Size of: ", stringify!(Elf64_Sym))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Sym>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Sym))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Sym>())).st_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Sym),
                "::",
                stringify!(st_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Sym>())).st_info as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Sym),
                "::",
                stringify!(st_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Sym>())).st_other as *const _ as usize },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Sym),
                "::",
                stringify!(st_other)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Sym>())).st_shndx as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Sym),
                "::",
                stringify!(st_shndx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Sym>())).st_value as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Sym),
                "::",
                stringify!(st_value)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Sym>())).st_size as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Sym),
                "::",
                stringify!(st_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Syminfo {
        pub si_boundto: root::Elf32_Half,
        pub si_flags: root::Elf32_Half,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Syminfo() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Syminfo>(),
            4usize,
            concat!("Size of: ", stringify!(Elf32_Syminfo))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Syminfo>(),
            2usize,
            concat!("Alignment of ", stringify!(Elf32_Syminfo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Syminfo>())).si_boundto as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Syminfo),
                "::",
                stringify!(si_boundto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Syminfo>())).si_flags as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Syminfo),
                "::",
                stringify!(si_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Syminfo {
        pub si_boundto: root::Elf64_Half,
        pub si_flags: root::Elf64_Half,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Syminfo() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Syminfo>(),
            4usize,
            concat!("Size of: ", stringify!(Elf64_Syminfo))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Syminfo>(),
            2usize,
            concat!("Alignment of ", stringify!(Elf64_Syminfo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Syminfo>())).si_boundto as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Syminfo),
                "::",
                stringify!(si_boundto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Syminfo>())).si_flags as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Syminfo),
                "::",
                stringify!(si_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Rel {
        pub r_offset: root::Elf32_Addr,
        pub r_info: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Rel() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Rel>(),
            8usize,
            concat!("Size of: ", stringify!(Elf32_Rel))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Rel>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Rel))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Rel>())).r_offset as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Rel),
                "::",
                stringify!(r_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Rel>())).r_info as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Rel),
                "::",
                stringify!(r_info)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Rel {
        pub r_offset: root::Elf64_Addr,
        pub r_info: root::Elf64_Xword,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Rel() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Rel>(),
            16usize,
            concat!("Size of: ", stringify!(Elf64_Rel))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Rel>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Rel))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Rel>())).r_offset as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Rel),
                "::",
                stringify!(r_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Rel>())).r_info as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Rel),
                "::",
                stringify!(r_info)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Rela {
        pub r_offset: root::Elf32_Addr,
        pub r_info: root::Elf32_Word,
        pub r_addend: root::Elf32_Sword,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Rela() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Rela>(),
            12usize,
            concat!("Size of: ", stringify!(Elf32_Rela))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Rela>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Rela))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Rela>())).r_offset as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Rela),
                "::",
                stringify!(r_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Rela>())).r_info as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Rela),
                "::",
                stringify!(r_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Rela>())).r_addend as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Rela),
                "::",
                stringify!(r_addend)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Rela {
        pub r_offset: root::Elf64_Addr,
        pub r_info: root::Elf64_Xword,
        pub r_addend: root::Elf64_Sxword,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Rela() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Rela>(),
            24usize,
            concat!("Size of: ", stringify!(Elf64_Rela))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Rela>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Rela))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Rela>())).r_offset as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Rela),
                "::",
                stringify!(r_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Rela>())).r_info as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Rela),
                "::",
                stringify!(r_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Rela>())).r_addend as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Rela),
                "::",
                stringify!(r_addend)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Phdr {
        pub p_type: root::Elf32_Word,
        pub p_offset: root::Elf32_Off,
        pub p_vaddr: root::Elf32_Addr,
        pub p_paddr: root::Elf32_Addr,
        pub p_filesz: root::Elf32_Word,
        pub p_memsz: root::Elf32_Word,
        pub p_flags: root::Elf32_Word,
        pub p_align: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Phdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Phdr>(),
            32usize,
            concat!("Size of: ", stringify!(Elf32_Phdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Phdr>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Phdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_offset as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_vaddr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_vaddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_paddr as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_paddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_filesz as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_filesz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_memsz as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_memsz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_flags as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Phdr>())).p_align as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Phdr),
                "::",
                stringify!(p_align)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Phdr {
        pub p_type: root::Elf64_Word,
        pub p_flags: root::Elf64_Word,
        pub p_offset: root::Elf64_Off,
        pub p_vaddr: root::Elf64_Addr,
        pub p_paddr: root::Elf64_Addr,
        pub p_filesz: root::Elf64_Xword,
        pub p_memsz: root::Elf64_Xword,
        pub p_align: root::Elf64_Xword,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Phdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Phdr>(),
            56usize,
            concat!("Size of: ", stringify!(Elf64_Phdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Phdr>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Phdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_flags as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_offset as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_vaddr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_vaddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_paddr as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_paddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_filesz as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_filesz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_memsz as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_memsz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Phdr>())).p_align as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Phdr),
                "::",
                stringify!(p_align)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct Elf32_Dyn {
        pub d_tag: root::Elf32_Sword,
        pub d_un: root::Elf32_Dyn__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union Elf32_Dyn__bindgen_ty_1 {
        pub d_val: root::Elf32_Word,
        pub d_ptr: root::Elf32_Addr,
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Dyn__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Dyn__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(Elf32_Dyn__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Dyn__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Dyn__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf32_Dyn__bindgen_ty_1>())).d_val as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Dyn__bindgen_ty_1),
                "::",
                stringify!(d_val)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf32_Dyn__bindgen_ty_1>())).d_ptr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Dyn__bindgen_ty_1),
                "::",
                stringify!(d_ptr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_Elf32_Dyn() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Dyn>(),
            8usize,
            concat!("Size of: ", stringify!(Elf32_Dyn))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Dyn>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Dyn))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Dyn>())).d_tag as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Dyn),
                "::",
                stringify!(d_tag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Dyn>())).d_un as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Dyn),
                "::",
                stringify!(d_un)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct Elf64_Dyn {
        pub d_tag: root::Elf64_Sxword,
        pub d_un: root::Elf64_Dyn__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union Elf64_Dyn__bindgen_ty_1 {
        pub d_val: root::Elf64_Xword,
        pub d_ptr: root::Elf64_Addr,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Dyn__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Dyn__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(Elf64_Dyn__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Dyn__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Dyn__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf64_Dyn__bindgen_ty_1>())).d_val as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Dyn__bindgen_ty_1),
                "::",
                stringify!(d_val)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf64_Dyn__bindgen_ty_1>())).d_ptr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Dyn__bindgen_ty_1),
                "::",
                stringify!(d_ptr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_Elf64_Dyn() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Dyn>(),
            16usize,
            concat!("Size of: ", stringify!(Elf64_Dyn))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Dyn>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Dyn))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Dyn>())).d_tag as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Dyn),
                "::",
                stringify!(d_tag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Dyn>())).d_un as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Dyn),
                "::",
                stringify!(d_un)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Verdef {
        pub vd_version: root::Elf32_Half,
        pub vd_flags: root::Elf32_Half,
        pub vd_ndx: root::Elf32_Half,
        pub vd_cnt: root::Elf32_Half,
        pub vd_hash: root::Elf32_Word,
        pub vd_aux: root::Elf32_Word,
        pub vd_next: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Verdef() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Verdef>(),
            20usize,
            concat!("Size of: ", stringify!(Elf32_Verdef))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Verdef>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Verdef))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdef>())).vd_version as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdef),
                "::",
                stringify!(vd_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdef>())).vd_flags as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdef),
                "::",
                stringify!(vd_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdef>())).vd_ndx as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdef),
                "::",
                stringify!(vd_ndx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdef>())).vd_cnt as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdef),
                "::",
                stringify!(vd_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdef>())).vd_hash as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdef),
                "::",
                stringify!(vd_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdef>())).vd_aux as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdef),
                "::",
                stringify!(vd_aux)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdef>())).vd_next as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdef),
                "::",
                stringify!(vd_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Verdef {
        pub vd_version: root::Elf64_Half,
        pub vd_flags: root::Elf64_Half,
        pub vd_ndx: root::Elf64_Half,
        pub vd_cnt: root::Elf64_Half,
        pub vd_hash: root::Elf64_Word,
        pub vd_aux: root::Elf64_Word,
        pub vd_next: root::Elf64_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Verdef() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Verdef>(),
            20usize,
            concat!("Size of: ", stringify!(Elf64_Verdef))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Verdef>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf64_Verdef))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdef>())).vd_version as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdef),
                "::",
                stringify!(vd_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdef>())).vd_flags as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdef),
                "::",
                stringify!(vd_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdef>())).vd_ndx as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdef),
                "::",
                stringify!(vd_ndx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdef>())).vd_cnt as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdef),
                "::",
                stringify!(vd_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdef>())).vd_hash as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdef),
                "::",
                stringify!(vd_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdef>())).vd_aux as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdef),
                "::",
                stringify!(vd_aux)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdef>())).vd_next as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdef),
                "::",
                stringify!(vd_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Verdaux {
        pub vda_name: root::Elf32_Word,
        pub vda_next: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Verdaux() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Verdaux>(),
            8usize,
            concat!("Size of: ", stringify!(Elf32_Verdaux))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Verdaux>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Verdaux))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdaux>())).vda_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdaux),
                "::",
                stringify!(vda_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verdaux>())).vda_next as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verdaux),
                "::",
                stringify!(vda_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Verdaux {
        pub vda_name: root::Elf64_Word,
        pub vda_next: root::Elf64_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Verdaux() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Verdaux>(),
            8usize,
            concat!("Size of: ", stringify!(Elf64_Verdaux))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Verdaux>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf64_Verdaux))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdaux>())).vda_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdaux),
                "::",
                stringify!(vda_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verdaux>())).vda_next as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verdaux),
                "::",
                stringify!(vda_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Verneed {
        pub vn_version: root::Elf32_Half,
        pub vn_cnt: root::Elf32_Half,
        pub vn_file: root::Elf32_Word,
        pub vn_aux: root::Elf32_Word,
        pub vn_next: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Verneed() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Verneed>(),
            16usize,
            concat!("Size of: ", stringify!(Elf32_Verneed))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Verneed>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Verneed))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verneed>())).vn_version as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verneed),
                "::",
                stringify!(vn_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verneed>())).vn_cnt as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verneed),
                "::",
                stringify!(vn_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verneed>())).vn_file as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verneed),
                "::",
                stringify!(vn_file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verneed>())).vn_aux as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verneed),
                "::",
                stringify!(vn_aux)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Verneed>())).vn_next as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Verneed),
                "::",
                stringify!(vn_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Verneed {
        pub vn_version: root::Elf64_Half,
        pub vn_cnt: root::Elf64_Half,
        pub vn_file: root::Elf64_Word,
        pub vn_aux: root::Elf64_Word,
        pub vn_next: root::Elf64_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Verneed() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Verneed>(),
            16usize,
            concat!("Size of: ", stringify!(Elf64_Verneed))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Verneed>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf64_Verneed))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verneed>())).vn_version as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verneed),
                "::",
                stringify!(vn_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verneed>())).vn_cnt as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verneed),
                "::",
                stringify!(vn_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verneed>())).vn_file as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verneed),
                "::",
                stringify!(vn_file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verneed>())).vn_aux as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verneed),
                "::",
                stringify!(vn_aux)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Verneed>())).vn_next as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Verneed),
                "::",
                stringify!(vn_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Vernaux {
        pub vna_hash: root::Elf32_Word,
        pub vna_flags: root::Elf32_Half,
        pub vna_other: root::Elf32_Half,
        pub vna_name: root::Elf32_Word,
        pub vna_next: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Vernaux() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Vernaux>(),
            16usize,
            concat!("Size of: ", stringify!(Elf32_Vernaux))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Vernaux>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Vernaux))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Vernaux>())).vna_hash as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Vernaux),
                "::",
                stringify!(vna_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Vernaux>())).vna_flags as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Vernaux),
                "::",
                stringify!(vna_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Vernaux>())).vna_other as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Vernaux),
                "::",
                stringify!(vna_other)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Vernaux>())).vna_name as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Vernaux),
                "::",
                stringify!(vna_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Vernaux>())).vna_next as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Vernaux),
                "::",
                stringify!(vna_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Vernaux {
        pub vna_hash: root::Elf64_Word,
        pub vna_flags: root::Elf64_Half,
        pub vna_other: root::Elf64_Half,
        pub vna_name: root::Elf64_Word,
        pub vna_next: root::Elf64_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Vernaux() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Vernaux>(),
            16usize,
            concat!("Size of: ", stringify!(Elf64_Vernaux))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Vernaux>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf64_Vernaux))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Vernaux>())).vna_hash as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Vernaux),
                "::",
                stringify!(vna_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Vernaux>())).vna_flags as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Vernaux),
                "::",
                stringify!(vna_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Vernaux>())).vna_other as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Vernaux),
                "::",
                stringify!(vna_other)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Vernaux>())).vna_name as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Vernaux),
                "::",
                stringify!(vna_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Vernaux>())).vna_next as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Vernaux),
                "::",
                stringify!(vna_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct Elf32_auxv_t {
        pub a_type: u32,
        pub a_un: root::Elf32_auxv_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union Elf32_auxv_t__bindgen_ty_1 {
        pub a_val: u32,
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout_Elf32_auxv_t__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_auxv_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(Elf32_auxv_t__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_auxv_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_auxv_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf32_auxv_t__bindgen_ty_1>())).a_val as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_auxv_t__bindgen_ty_1),
                "::",
                stringify!(a_val)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_Elf32_auxv_t() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_auxv_t>(),
            8usize,
            concat!("Size of: ", stringify!(Elf32_auxv_t))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_auxv_t>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_auxv_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_auxv_t>())).a_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_auxv_t),
                "::",
                stringify!(a_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_auxv_t>())).a_un as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_auxv_t),
                "::",
                stringify!(a_un)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct Elf64_auxv_t {
        pub a_type: u64,
        pub a_un: root::Elf64_auxv_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union Elf64_auxv_t__bindgen_ty_1 {
        pub a_val: u64,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_Elf64_auxv_t__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_auxv_t__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(Elf64_auxv_t__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_auxv_t__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_auxv_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf64_auxv_t__bindgen_ty_1>())).a_val as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_auxv_t__bindgen_ty_1),
                "::",
                stringify!(a_val)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_Elf64_auxv_t() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_auxv_t>(),
            16usize,
            concat!("Size of: ", stringify!(Elf64_auxv_t))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_auxv_t>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_auxv_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_auxv_t>())).a_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_auxv_t),
                "::",
                stringify!(a_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_auxv_t>())).a_un as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_auxv_t),
                "::",
                stringify!(a_un)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Nhdr {
        pub n_namesz: root::Elf32_Word,
        pub n_descsz: root::Elf32_Word,
        pub n_type: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Nhdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Nhdr>(),
            12usize,
            concat!("Size of: ", stringify!(Elf32_Nhdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Nhdr>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Nhdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Nhdr>())).n_namesz as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Nhdr),
                "::",
                stringify!(n_namesz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Nhdr>())).n_descsz as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Nhdr),
                "::",
                stringify!(n_descsz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Nhdr>())).n_type as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Nhdr),
                "::",
                stringify!(n_type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Nhdr {
        pub n_namesz: root::Elf64_Word,
        pub n_descsz: root::Elf64_Word,
        pub n_type: root::Elf64_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Nhdr() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Nhdr>(),
            12usize,
            concat!("Size of: ", stringify!(Elf64_Nhdr))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Nhdr>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf64_Nhdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Nhdr>())).n_namesz as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Nhdr),
                "::",
                stringify!(n_namesz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Nhdr>())).n_descsz as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Nhdr),
                "::",
                stringify!(n_descsz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Nhdr>())).n_type as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Nhdr),
                "::",
                stringify!(n_type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Move {
        pub m_value: root::Elf32_Xword,
        pub m_info: root::Elf32_Word,
        pub m_poffset: root::Elf32_Word,
        pub m_repeat: root::Elf32_Half,
        pub m_stride: root::Elf32_Half,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Move() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Move>(),
            24usize,
            concat!("Size of: ", stringify!(Elf32_Move))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Move>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf32_Move))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Move>())).m_value as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Move),
                "::",
                stringify!(m_value)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Move>())).m_info as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Move),
                "::",
                stringify!(m_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Move>())).m_poffset as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Move),
                "::",
                stringify!(m_poffset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Move>())).m_repeat as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Move),
                "::",
                stringify!(m_repeat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Move>())).m_stride as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Move),
                "::",
                stringify!(m_stride)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Move {
        pub m_value: root::Elf64_Xword,
        pub m_info: root::Elf64_Xword,
        pub m_poffset: root::Elf64_Xword,
        pub m_repeat: root::Elf64_Half,
        pub m_stride: root::Elf64_Half,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Move() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Move>(),
            32usize,
            concat!("Size of: ", stringify!(Elf64_Move))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Move>(),
            8usize,
            concat!("Alignment of ", stringify!(Elf64_Move))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Move>())).m_value as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Move),
                "::",
                stringify!(m_value)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Move>())).m_info as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Move),
                "::",
                stringify!(m_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Move>())).m_poffset as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Move),
                "::",
                stringify!(m_poffset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Move>())).m_repeat as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Move),
                "::",
                stringify!(m_repeat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Move>())).m_stride as *const _ as usize },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Move),
                "::",
                stringify!(m_stride)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union Elf32_gptab {
        pub gt_header: root::Elf32_gptab__bindgen_ty_1,
        pub gt_entry: root::Elf32_gptab__bindgen_ty_2,
        _bindgen_union_align: [u32; 2usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_gptab__bindgen_ty_1 {
        pub gt_current_g_value: root::Elf32_Word,
        pub gt_unused: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_gptab__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_gptab__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(Elf32_gptab__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_gptab__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_gptab__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf32_gptab__bindgen_ty_1>())).gt_current_g_value
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_gptab__bindgen_ty_1),
                "::",
                stringify!(gt_current_g_value)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf32_gptab__bindgen_ty_1>())).gt_unused as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_gptab__bindgen_ty_1),
                "::",
                stringify!(gt_unused)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_gptab__bindgen_ty_2 {
        pub gt_g_value: root::Elf32_Word,
        pub gt_bytes: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_gptab__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_gptab__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(Elf32_gptab__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_gptab__bindgen_ty_2>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_gptab__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf32_gptab__bindgen_ty_2>())).gt_g_value as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_gptab__bindgen_ty_2),
                "::",
                stringify!(gt_g_value)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf32_gptab__bindgen_ty_2>())).gt_bytes as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_gptab__bindgen_ty_2),
                "::",
                stringify!(gt_bytes)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_Elf32_gptab() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_gptab>(),
            8usize,
            concat!("Size of: ", stringify!(Elf32_gptab))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_gptab>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_gptab))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_gptab>())).gt_header as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_gptab),
                "::",
                stringify!(gt_header)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_gptab>())).gt_entry as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_gptab),
                "::",
                stringify!(gt_entry)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_RegInfo {
        pub ri_gprmask: root::Elf32_Word,
        pub ri_cprmask: [root::Elf32_Word; 4usize],
        pub ri_gp_value: root::Elf32_Sword,
    }
    #[test]
    fn bindgen_test_layout_Elf32_RegInfo() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_RegInfo>(),
            24usize,
            concat!("Size of: ", stringify!(Elf32_RegInfo))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_RegInfo>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_RegInfo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_RegInfo>())).ri_gprmask as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_RegInfo),
                "::",
                stringify!(ri_gprmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_RegInfo>())).ri_cprmask as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_RegInfo),
                "::",
                stringify!(ri_cprmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_RegInfo>())).ri_gp_value as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_RegInfo),
                "::",
                stringify!(ri_gp_value)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf_Options {
        pub kind: libc::c_uchar,
        pub size: libc::c_uchar,
        pub section: root::Elf32_Section,
        pub info: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf_Options() {
        assert_eq!(
            ::core::mem::size_of::<Elf_Options>(),
            8usize,
            concat!("Size of: ", stringify!(Elf_Options))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf_Options>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf_Options))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf_Options>())).kind as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_Options),
                "::",
                stringify!(kind)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf_Options>())).size as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_Options),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf_Options>())).section as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_Options),
                "::",
                stringify!(section)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf_Options>())).info as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_Options),
                "::",
                stringify!(info)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf_Options_Hw {
        pub hwp_flags1: root::Elf32_Word,
        pub hwp_flags2: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf_Options_Hw() {
        assert_eq!(
            ::core::mem::size_of::<Elf_Options_Hw>(),
            8usize,
            concat!("Size of: ", stringify!(Elf_Options_Hw))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf_Options_Hw>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf_Options_Hw))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf_Options_Hw>())).hwp_flags1 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_Options_Hw),
                "::",
                stringify!(hwp_flags1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf_Options_Hw>())).hwp_flags2 as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_Options_Hw),
                "::",
                stringify!(hwp_flags2)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf32_Lib {
        pub l_name: root::Elf32_Word,
        pub l_time_stamp: root::Elf32_Word,
        pub l_checksum: root::Elf32_Word,
        pub l_version: root::Elf32_Word,
        pub l_flags: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf32_Lib() {
        assert_eq!(
            ::core::mem::size_of::<Elf32_Lib>(),
            20usize,
            concat!("Size of: ", stringify!(Elf32_Lib))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf32_Lib>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf32_Lib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Lib>())).l_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Lib),
                "::",
                stringify!(l_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Lib>())).l_time_stamp as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Lib),
                "::",
                stringify!(l_time_stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Lib>())).l_checksum as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Lib),
                "::",
                stringify!(l_checksum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Lib>())).l_version as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Lib),
                "::",
                stringify!(l_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf32_Lib>())).l_flags as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf32_Lib),
                "::",
                stringify!(l_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf64_Lib {
        pub l_name: root::Elf64_Word,
        pub l_time_stamp: root::Elf64_Word,
        pub l_checksum: root::Elf64_Word,
        pub l_version: root::Elf64_Word,
        pub l_flags: root::Elf64_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf64_Lib() {
        assert_eq!(
            ::core::mem::size_of::<Elf64_Lib>(),
            20usize,
            concat!("Size of: ", stringify!(Elf64_Lib))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf64_Lib>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf64_Lib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Lib>())).l_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Lib),
                "::",
                stringify!(l_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Lib>())).l_time_stamp as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Lib),
                "::",
                stringify!(l_time_stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Lib>())).l_checksum as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Lib),
                "::",
                stringify!(l_checksum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Lib>())).l_version as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Lib),
                "::",
                stringify!(l_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf64_Lib>())).l_flags as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf64_Lib),
                "::",
                stringify!(l_flags)
            )
        );
    }
    pub type Elf32_Conflict = root::Elf32_Addr;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Elf_MIPS_ABIFlags_v0 {
        pub version: root::Elf32_Half,
        pub isa_level: libc::c_uchar,
        pub isa_rev: libc::c_uchar,
        pub gpr_size: libc::c_uchar,
        pub cpr1_size: libc::c_uchar,
        pub cpr2_size: libc::c_uchar,
        pub fp_abi: libc::c_uchar,
        pub isa_ext: root::Elf32_Word,
        pub ases: root::Elf32_Word,
        pub flags1: root::Elf32_Word,
        pub flags2: root::Elf32_Word,
    }
    #[test]
    fn bindgen_test_layout_Elf_MIPS_ABIFlags_v0() {
        assert_eq!(
            ::core::mem::size_of::<Elf_MIPS_ABIFlags_v0>(),
            24usize,
            concat!("Size of: ", stringify!(Elf_MIPS_ABIFlags_v0))
        );
        assert_eq!(
            ::core::mem::align_of::<Elf_MIPS_ABIFlags_v0>(),
            4usize,
            concat!("Alignment of ", stringify!(Elf_MIPS_ABIFlags_v0))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).version as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(version)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).isa_level as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(isa_level)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).isa_rev as *const _ as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(isa_rev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).gpr_size as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(gpr_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).cpr1_size as *const _ as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(cpr1_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).cpr2_size as *const _ as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(cpr2_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).fp_abi as *const _ as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(fp_abi)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).isa_ext as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(isa_ext)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).ases as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(ases)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).flags1 as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(flags1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<Elf_MIPS_ABIFlags_v0>())).flags2 as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(Elf_MIPS_ABIFlags_v0),
                "::",
                stringify!(flags2)
            )
        );
    }
    pub const Val_GNU_MIPS_ABI_FP_ANY: root::_bindgen_ty_6 = 0;
    pub const Val_GNU_MIPS_ABI_FP_DOUBLE: root::_bindgen_ty_6 = 1;
    pub const Val_GNU_MIPS_ABI_FP_SINGLE: root::_bindgen_ty_6 = 2;
    pub const Val_GNU_MIPS_ABI_FP_SOFT: root::_bindgen_ty_6 = 3;
    pub const Val_GNU_MIPS_ABI_FP_OLD_64: root::_bindgen_ty_6 = 4;
    pub const Val_GNU_MIPS_ABI_FP_XX: root::_bindgen_ty_6 = 5;
    pub const Val_GNU_MIPS_ABI_FP_64: root::_bindgen_ty_6 = 6;
    pub const Val_GNU_MIPS_ABI_FP_64A: root::_bindgen_ty_6 = 7;
    pub const Val_GNU_MIPS_ABI_FP_MAX: root::_bindgen_ty_6 = 7;
    pub type _bindgen_ty_6 = u32;
    pub mod rtld {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ModuleObject {
            pub next: *mut root::rtld::ModuleObject,
            pub prev: *mut root::rtld::ModuleObject,
            pub rela_or_rel_plt: root::rtld::ModuleObject__bindgen_ty_1,
            pub rela_or_rel: root::rtld::ModuleObject__bindgen_ty_2,
            pub module_base: u64,
            pub dynamic: *mut root::Elf64_Dyn,
            pub is_rela: bool,
            pub rela_or_rel_plt_size: u64,
            pub dt_init: ::core::option::Option<unsafe extern "C" fn()>,
            pub dt_fini: ::core::option::Option<unsafe extern "C" fn()>,
            pub hash_bucket: *mut u32,
            pub hash_chain: *mut u32,
            pub dynstr: *mut libc::c_char,
            pub dynsym: *mut root::Elf64_Sym,
            pub dynstr_size: u64,
            pub got: *mut *mut libc::c_void,
            pub rela_dyn_size: u64,
            pub rel_dyn_size: u64,
            pub rel_count: u64,
            pub rela_count: u64,
            pub hash_nchain_value: u64,
            pub hash_nbucket_value: u64,
            pub got_stub_ptr: u64,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union ModuleObject__bindgen_ty_1 {
            pub rel: *mut root::Elf64_Rel,
            pub rela: *mut root::Elf64_Rela,
            pub raw: *mut libc::c_void,
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout_ModuleObject__bindgen_ty_1() {
            assert_eq!(
                ::core::mem::size_of::<ModuleObject__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(ModuleObject__bindgen_ty_1))
            );
            assert_eq!(
                ::core::mem::align_of::<ModuleObject__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(ModuleObject__bindgen_ty_1))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject__bindgen_ty_1>())).rel as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject__bindgen_ty_1),
                    "::",
                    stringify!(rel)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject__bindgen_ty_1>())).rela as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject__bindgen_ty_1),
                    "::",
                    stringify!(rela)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject__bindgen_ty_1>())).raw as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject__bindgen_ty_1),
                    "::",
                    stringify!(raw)
                )
            );
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union ModuleObject__bindgen_ty_2 {
            pub rel: *mut root::Elf64_Rel,
            pub rela: *mut root::Elf64_Rela,
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout_ModuleObject__bindgen_ty_2() {
            assert_eq!(
                ::core::mem::size_of::<ModuleObject__bindgen_ty_2>(),
                8usize,
                concat!("Size of: ", stringify!(ModuleObject__bindgen_ty_2))
            );
            assert_eq!(
                ::core::mem::align_of::<ModuleObject__bindgen_ty_2>(),
                8usize,
                concat!("Alignment of ", stringify!(ModuleObject__bindgen_ty_2))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject__bindgen_ty_2>())).rel as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject__bindgen_ty_2),
                    "::",
                    stringify!(rel)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject__bindgen_ty_2>())).rela as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject__bindgen_ty_2),
                    "::",
                    stringify!(rela)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_ModuleObject() {
            assert_eq!(
                ::core::mem::size_of::<ModuleObject>(),
                184usize,
                concat!("Size of: ", stringify!(ModuleObject))
            );
            assert_eq!(
                ::core::mem::align_of::<ModuleObject>(),
                8usize,
                concat!("Alignment of ", stringify!(ModuleObject))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).next as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(next)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).prev as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(prev)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).rela_or_rel_plt as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(rela_or_rel_plt)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).rela_or_rel as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(rela_or_rel)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).module_base as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(module_base)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).dynamic as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(dynamic)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).is_rela as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(is_rela)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).rela_or_rel_plt_size as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(rela_or_rel_plt_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).dt_init as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(dt_init)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).dt_fini as *const _ as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(dt_fini)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).hash_bucket as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(hash_bucket)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).hash_chain as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(hash_chain)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).dynstr as *const _ as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(dynstr)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).dynsym as *const _ as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(dynsym)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).dynstr_size as *const _ as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(dynstr_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).got as *const _ as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(got)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).rela_dyn_size as *const _ as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(rela_dyn_size)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).rel_dyn_size as *const _ as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(rel_dyn_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<ModuleObject>())).rel_count as *const _ as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(rel_count)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).rela_count as *const _ as usize
                },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(rela_count)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).hash_nchain_value as *const _ as usize
                },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(hash_nchain_value)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).hash_nbucket_value as *const _
                        as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(hash_nbucket_value)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<ModuleObject>())).got_stub_ptr as *const _ as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModuleObject),
                    "::",
                    stringify!(got_stub_ptr)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4rtld12ModuleObject10InitializeEmP9Elf64_Dyn"]
            pub fn ModuleObject_Initialize(
                this: *mut root::rtld::ModuleObject,
                aslr_base: u64,
                dynamic: *mut root::Elf64_Dyn,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4rtld12ModuleObject8RelocateEv"]
            pub fn ModuleObject_Relocate(this: *mut root::rtld::ModuleObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4rtld12ModuleObject15GetSymbolByNameEPKc"]
            pub fn ModuleObject_GetSymbolByName(
                this: *mut root::rtld::ModuleObject,
                name: *const libc::c_char,
            ) -> *mut root::Elf64_Sym;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4rtld12ModuleObject14ResolveSymbolsEb"]
            pub fn ModuleObject_ResolveSymbols(
                this: *mut root::rtld::ModuleObject,
                do_lazy_got_init: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4rtld12ModuleObject16TryResolveSymbolEPmP9Elf64_Sym"]
            pub fn ModuleObject_TryResolveSymbol(
                this: *mut root::rtld::ModuleObject,
                target_symbol_address: *mut root::Elf64_Addr,
                symbol: *mut root::Elf64_Sym,
            ) -> bool;
        }
        impl ModuleObject {
            #[inline]
            pub unsafe fn Initialize(&mut self, aslr_base: u64, dynamic: *mut root::Elf64_Dyn) {
                ModuleObject_Initialize(self, aslr_base, dynamic)
            }
            #[inline]
            pub unsafe fn Relocate(&mut self) {
                ModuleObject_Relocate(self)
            }
            #[inline]
            pub unsafe fn GetSymbolByName(
                &mut self,
                name: *const libc::c_char,
            ) -> *mut root::Elf64_Sym {
                ModuleObject_GetSymbolByName(self, name)
            }
            #[inline]
            pub unsafe fn ResolveSymbols(&mut self, do_lazy_got_init: bool) {
                ModuleObject_ResolveSymbols(self, do_lazy_got_init)
            }
            #[inline]
            pub unsafe fn TryResolveSymbol(
                &mut self,
                target_symbol_address: *mut root::Elf64_Addr,
                symbol: *mut root::Elf64_Sym,
            ) -> bool {
                ModuleObject_TryResolveSymbol(self, target_symbol_address, symbol)
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iovec {
        pub iov_base: *mut libc::c_void,
        pub iov_len: root::size_t,
    }
    #[test]
    fn bindgen_test_layout_iovec() {
        assert_eq!(
            ::core::mem::size_of::<iovec>(),
            16usize,
            concat!("Size of: ", stringify!(iovec))
        );
        assert_eq!(
            ::core::mem::align_of::<iovec>(),
            8usize,
            concat!("Alignment of ", stringify!(iovec))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_len)
            )
        );
    }
    pub type u_char = root::__u_char;
    pub type u_short = root::__u_short;
    pub type u_int = root::__u_int;
    pub type u_long = root::__u_long;
    pub type quad_t = root::__quad_t;
    pub type u_quad_t = root::__u_quad_t;
    pub type fsid_t = root::__fsid_t;
    pub type loff_t = root::__loff_t;
    pub type ino_t = root::__ino_t;
    pub type ino64_t = root::__ino64_t;
    pub type dev_t = root::__dev_t;
    pub type gid_t = root::__gid_t;
    pub type mode_t = root::__mode_t;
    pub type nlink_t = root::__nlink_t;
    pub type uid_t = root::__uid_t;
    pub type off_t = root::__off_t;
    pub type off64_t = root::__off64_t;
    pub type pid_t = root::__pid_t;
    pub type id_t = root::__id_t;
    pub type ssize_t = root::__ssize_t;
    pub type daddr_t = root::__daddr_t;
    pub type caddr_t = root::__caddr_t;
    pub type key_t = root::__key_t;
    pub type clock_t = root::__clock_t;
    pub type clockid_t = root::__clockid_t;
    pub type time_t = root::__time_t;
    pub type timer_t = root::__timer_t;
    pub type useconds_t = root::__useconds_t;
    pub type suseconds_t = root::__suseconds_t;
    pub type ushort = libc::c_ushort;
    pub type u_int8_t = root::__uint8_t;
    pub type u_int16_t = root::__uint16_t;
    pub type u_int32_t = root::__uint32_t;
    pub type u_int64_t = root::__uint64_t;
    pub type register_t = libc::c_long;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sigset_t {
        pub __val: [libc::c_ulong; 16usize],
    }
    #[test]
    fn bindgen_test_layout___sigset_t() {
        assert_eq!(
            ::core::mem::size_of::<__sigset_t>(),
            128usize,
            concat!("Size of: ", stringify!(__sigset_t))
        );
        assert_eq!(
            ::core::mem::align_of::<__sigset_t>(),
            8usize,
            concat!("Alignment of ", stringify!(__sigset_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    pub type sigset_t = root::__sigset_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct timeval {
        pub tv_sec: root::__time_t,
        pub tv_usec: root::__suseconds_t,
    }
    #[test]
    fn bindgen_test_layout_timeval() {
        assert_eq!(
            ::core::mem::size_of::<timeval>(),
            16usize,
            concat!("Size of: ", stringify!(timeval))
        );
        assert_eq!(
            ::core::mem::align_of::<timeval>(),
            8usize,
            concat!("Alignment of ", stringify!(timeval))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct timespec {
        pub tv_sec: root::__time_t,
        pub tv_nsec: root::__syscall_slong_t,
    }
    #[test]
    fn bindgen_test_layout_timespec() {
        assert_eq!(
            ::core::mem::size_of::<timespec>(),
            16usize,
            concat!("Size of: ", stringify!(timespec))
        );
        assert_eq!(
            ::core::mem::align_of::<timespec>(),
            8usize,
            concat!("Alignment of ", stringify!(timespec))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    pub type __fd_mask = libc::c_long;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fd_set {
        pub fds_bits: [root::__fd_mask; 16usize],
    }
    #[test]
    fn bindgen_test_layout_fd_set() {
        assert_eq!(
            ::core::mem::size_of::<fd_set>(),
            128usize,
            concat!("Size of: ", stringify!(fd_set))
        );
        assert_eq!(
            ::core::mem::align_of::<fd_set>(),
            8usize,
            concat!("Alignment of ", stringify!(fd_set))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(fds_bits)
            )
        );
    }
    pub type fd_mask = root::__fd_mask;
    extern "C" {
        pub fn select(
            __nfds: libc::c_int,
            __readfds: *mut root::fd_set,
            __writefds: *mut root::fd_set,
            __exceptfds: *mut root::fd_set,
            __timeout: *mut root::timeval,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn pselect(
            __nfds: libc::c_int,
            __readfds: *mut root::fd_set,
            __writefds: *mut root::fd_set,
            __exceptfds: *mut root::fd_set,
            __timeout: *const root::timespec,
            __sigmask: *const root::__sigset_t,
        ) -> libc::c_int;
    }
    pub type blksize_t = root::__blksize_t;
    pub type blkcnt_t = root::__blkcnt_t;
    pub type fsblkcnt_t = root::__fsblkcnt_t;
    pub type fsfilcnt_t = root::__fsfilcnt_t;
    pub type blkcnt64_t = root::__blkcnt64_t;
    pub type fsblkcnt64_t = root::__fsblkcnt64_t;
    pub type fsfilcnt64_t = root::__fsfilcnt64_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __pthread_rwlock_arch_t {
        pub __readers: libc::c_uint,
        pub __writers: libc::c_uint,
        pub __wrphase_futex: libc::c_uint,
        pub __writers_futex: libc::c_uint,
        pub __pad3: libc::c_uint,
        pub __pad4: libc::c_uint,
        pub __cur_writer: libc::c_int,
        pub __shared: libc::c_int,
        pub __rwelision: libc::c_schar,
        pub __pad1: [libc::c_uchar; 7usize],
        pub __pad2: libc::c_ulong,
        pub __flags: libc::c_uint,
    }
    #[test]
    fn bindgen_test_layout___pthread_rwlock_arch_t() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
            56usize,
            concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__readers)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__wrphase_futex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _
                    as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers_futex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__cur_writer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__shared)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__rwelision)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __pthread_internal_list {
        pub __prev: *mut root::__pthread_internal_list,
        pub __next: *mut root::__pthread_internal_list,
    }
    #[test]
    fn bindgen_test_layout___pthread_internal_list() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_internal_list>(),
            16usize,
            concat!("Size of: ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_internal_list>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    pub type __pthread_list_t = root::__pthread_internal_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __pthread_mutex_s {
        pub __lock: libc::c_int,
        pub __count: libc::c_uint,
        pub __owner: libc::c_int,
        pub __nusers: libc::c_uint,
        pub __kind: libc::c_int,
        pub __spins: libc::c_short,
        pub __elision: libc::c_short,
        pub __list: root::__pthread_list_t,
    }
    #[test]
    fn bindgen_test_layout___pthread_mutex_s() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_mutex_s>(),
            40usize,
            concat!("Size of: ", stringify!(__pthread_mutex_s))
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_mutex_s>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_mutex_s))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __pthread_cond_s {
        pub __bindgen_anon_1: root::__pthread_cond_s__bindgen_ty_1,
        pub __bindgen_anon_2: root::__pthread_cond_s__bindgen_ty_2,
        pub __g_refs: [libc::c_uint; 2usize],
        pub __g_size: [libc::c_uint; 2usize],
        pub __g1_orig_size: libc::c_uint,
        pub __wrefs: libc::c_uint,
        pub __g_signals: [libc::c_uint; 2usize],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __pthread_cond_s__bindgen_ty_1 {
        pub __wseq: libc::c_ulonglong,
        pub __wseq32: root::__pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
        _bindgen_union_align: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
        pub __low: libc::c_uint,
        pub __high: libc::c_uint,
    }
    #[test]
    fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq32)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __pthread_cond_s__bindgen_ty_2 {
        pub __g1_start: libc::c_ulonglong,
        pub __g1_start32: root::__pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
        _bindgen_union_align: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
        pub __low: libc::c_uint,
        pub __high: libc::c_uint,
    }
    #[test]
    fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start32)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___pthread_cond_s() {
        assert_eq!(
            ::core::mem::size_of::<__pthread_cond_s>(),
            48usize,
            concat!("Size of: ", stringify!(__pthread_cond_s))
        );
        assert_eq!(
            ::core::mem::align_of::<__pthread_cond_s>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_cond_s))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    pub type pthread_t = libc::c_ulong;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_mutexattr_t {
        pub __size: [libc::c_char; 4usize],
        pub __align: libc::c_int,
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout_pthread_mutexattr_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_mutexattr_t>(),
            4usize,
            concat!("Size of: ", stringify!(pthread_mutexattr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_mutexattr_t>(),
            4usize,
            concat!("Alignment of ", stringify!(pthread_mutexattr_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_condattr_t {
        pub __size: [libc::c_char; 4usize],
        pub __align: libc::c_int,
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout_pthread_condattr_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_condattr_t>(),
            4usize,
            concat!("Size of: ", stringify!(pthread_condattr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_condattr_t>(),
            4usize,
            concat!("Alignment of ", stringify!(pthread_condattr_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    pub type pthread_key_t = libc::c_uint;
    pub type pthread_once_t = libc::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_attr_t {
        pub __size: [libc::c_char; 56usize],
        pub __align: libc::c_long,
        _bindgen_union_align: [u64; 7usize],
    }
    #[test]
    fn bindgen_test_layout_pthread_attr_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_attr_t>(),
            56usize,
            concat!("Size of: ", stringify!(pthread_attr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_attr_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_attr_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_mutex_t {
        pub __data: root::__pthread_mutex_s,
        pub __size: [libc::c_char; 40usize],
        pub __align: libc::c_long,
        _bindgen_union_align: [u64; 5usize],
    }
    #[test]
    fn bindgen_test_layout_pthread_mutex_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_mutex_t>(),
            40usize,
            concat!("Size of: ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_mutex_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_cond_t {
        pub __data: root::__pthread_cond_s,
        pub __size: [libc::c_char; 48usize],
        pub __align: libc::c_longlong,
        _bindgen_union_align: [u64; 6usize],
    }
    #[test]
    fn bindgen_test_layout_pthread_cond_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_cond_t>(),
            48usize,
            concat!("Size of: ", stringify!(pthread_cond_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_cond_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_cond_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_rwlock_t {
        pub __data: root::__pthread_rwlock_arch_t,
        pub __size: [libc::c_char; 56usize],
        pub __align: libc::c_long,
        _bindgen_union_align: [u64; 7usize],
    }
    #[test]
    fn bindgen_test_layout_pthread_rwlock_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_rwlock_t>(),
            56usize,
            concat!("Size of: ", stringify!(pthread_rwlock_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_rwlock_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_rwlock_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__align)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_rwlockattr_t {
        pub __size: [libc::c_char; 8usize],
        pub __align: libc::c_long,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_pthread_rwlockattr_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_rwlockattr_t>(),
            8usize,
            concat!("Size of: ", stringify!(pthread_rwlockattr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_rwlockattr_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    pub type pthread_spinlock_t = libc::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_barrier_t {
        pub __size: [libc::c_char; 32usize],
        pub __align: libc::c_long,
        _bindgen_union_align: [u64; 4usize],
    }
    #[test]
    fn bindgen_test_layout_pthread_barrier_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_barrier_t>(),
            32usize,
            concat!("Size of: ", stringify!(pthread_barrier_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_barrier_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_barrier_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__align)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_barrierattr_t {
        pub __size: [libc::c_char; 4usize],
        pub __align: libc::c_int,
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout_pthread_barrierattr_t() {
        assert_eq!(
            ::core::mem::size_of::<pthread_barrierattr_t>(),
            4usize,
            concat!("Size of: ", stringify!(pthread_barrierattr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pthread_barrierattr_t>(),
            4usize,
            concat!("Alignment of ", stringify!(pthread_barrierattr_t))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    pub type socklen_t = root::__socklen_t;
    pub const __socket_type_SOCK_STREAM: root::__socket_type = 1;
    pub const __socket_type_SOCK_DGRAM: root::__socket_type = 2;
    pub const __socket_type_SOCK_RAW: root::__socket_type = 3;
    pub const __socket_type_SOCK_RDM: root::__socket_type = 4;
    pub const __socket_type_SOCK_SEQPACKET: root::__socket_type = 5;
    pub const __socket_type_SOCK_DCCP: root::__socket_type = 6;
    pub const __socket_type_SOCK_PACKET: root::__socket_type = 10;
    pub const __socket_type_SOCK_CLOEXEC: root::__socket_type = 524288;
    pub const __socket_type_SOCK_NONBLOCK: root::__socket_type = 2048;
    pub type __socket_type = u32;
    pub type sa_family_t = libc::c_ushort;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sockaddr {
        pub sa_family: root::sa_family_t,
        pub sa_data: [libc::c_char; 14usize],
    }
    #[test]
    fn bindgen_test_layout_sockaddr() {
        assert_eq!(
            ::core::mem::size_of::<sockaddr>(),
            16usize,
            concat!("Size of: ", stringify!(sockaddr))
        );
        assert_eq!(
            ::core::mem::align_of::<sockaddr>(),
            2usize,
            concat!("Alignment of ", stringify!(sockaddr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_data)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sockaddr_storage {
        pub ss_family: root::sa_family_t,
        pub __ss_padding: [libc::c_char; 118usize],
        pub __ss_align: libc::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_sockaddr_storage() {
        assert_eq!(
            ::core::mem::size_of::<sockaddr_storage>(),
            128usize,
            concat!("Size of: ", stringify!(sockaddr_storage))
        );
        assert_eq!(
            ::core::mem::align_of::<sockaddr_storage>(),
            8usize,
            concat!("Alignment of ", stringify!(sockaddr_storage))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(ss_family)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_padding)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_align)
            )
        );
    }
    pub const MSG_OOB: root::_bindgen_ty_7 = 1;
    pub const MSG_PEEK: root::_bindgen_ty_7 = 2;
    pub const MSG_DONTROUTE: root::_bindgen_ty_7 = 4;
    pub const MSG_TRYHARD: root::_bindgen_ty_7 = 4;
    pub const MSG_CTRUNC: root::_bindgen_ty_7 = 8;
    pub const MSG_PROXY: root::_bindgen_ty_7 = 16;
    pub const MSG_TRUNC: root::_bindgen_ty_7 = 32;
    pub const MSG_DONTWAIT: root::_bindgen_ty_7 = 64;
    pub const MSG_EOR: root::_bindgen_ty_7 = 128;
    pub const MSG_WAITALL: root::_bindgen_ty_7 = 256;
    pub const MSG_FIN: root::_bindgen_ty_7 = 512;
    pub const MSG_SYN: root::_bindgen_ty_7 = 1024;
    pub const MSG_CONFIRM: root::_bindgen_ty_7 = 2048;
    pub const MSG_RST: root::_bindgen_ty_7 = 4096;
    pub const MSG_ERRQUEUE: root::_bindgen_ty_7 = 8192;
    pub const MSG_NOSIGNAL: root::_bindgen_ty_7 = 16384;
    pub const MSG_MORE: root::_bindgen_ty_7 = 32768;
    pub const MSG_WAITFORONE: root::_bindgen_ty_7 = 65536;
    pub const MSG_BATCH: root::_bindgen_ty_7 = 262144;
    pub const MSG_ZEROCOPY: root::_bindgen_ty_7 = 67108864;
    pub const MSG_FASTOPEN: root::_bindgen_ty_7 = 536870912;
    pub const MSG_CMSG_CLOEXEC: root::_bindgen_ty_7 = 1073741824;
    pub type _bindgen_ty_7 = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct msghdr {
        pub msg_name: *mut libc::c_void,
        pub msg_namelen: root::socklen_t,
        pub msg_iov: *mut root::iovec,
        pub msg_iovlen: root::size_t,
        pub msg_control: *mut libc::c_void,
        pub msg_controllen: root::size_t,
        pub msg_flags: libc::c_int,
    }
    #[test]
    fn bindgen_test_layout_msghdr() {
        assert_eq!(
            ::core::mem::size_of::<msghdr>(),
            56usize,
            concat!("Size of: ", stringify!(msghdr))
        );
        assert_eq!(
            ::core::mem::align_of::<msghdr>(),
            8usize,
            concat!("Alignment of ", stringify!(msghdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_namelen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iov)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iovlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_control as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_control)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_controllen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct cmsghdr {
        pub cmsg_len: root::size_t,
        pub cmsg_level: libc::c_int,
        pub cmsg_type: libc::c_int,
        pub __cmsg_data: root::__IncompleteArrayField<libc::c_uchar>,
    }
    #[test]
    fn bindgen_test_layout_cmsghdr() {
        assert_eq!(
            ::core::mem::size_of::<cmsghdr>(),
            16usize,
            concat!("Size of: ", stringify!(cmsghdr))
        );
        assert_eq!(
            ::core::mem::align_of::<cmsghdr>(),
            8usize,
            concat!("Alignment of ", stringify!(cmsghdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(__cmsg_data)
            )
        );
    }
    extern "C" {
        pub fn __cmsg_nxthdr(
            __mhdr: *mut root::msghdr,
            __cmsg: *mut root::cmsghdr,
        ) -> *mut root::cmsghdr;
    }
    pub const SCM_RIGHTS: root::_bindgen_ty_8 = 1;
    pub const SCM_CREDENTIALS: root::_bindgen_ty_8 = 2;
    pub type _bindgen_ty_8 = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ucred {
        pub pid: root::pid_t,
        pub uid: root::uid_t,
        pub gid: root::gid_t,
    }
    #[test]
    fn bindgen_test_layout_ucred() {
        assert_eq!(
            ::core::mem::size_of::<ucred>(),
            12usize,
            concat!("Size of: ", stringify!(ucred))
        );
        assert_eq!(
            ::core::mem::align_of::<ucred>(),
            4usize,
            concat!("Alignment of ", stringify!(ucred))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucred>())).pid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ucred),
                "::",
                stringify!(pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucred>())).uid as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ucred),
                "::",
                stringify!(uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucred>())).gid as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ucred),
                "::",
                stringify!(gid)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __kernel_fd_set {
        pub fds_bits: [libc::c_ulong; 16usize],
    }
    #[test]
    fn bindgen_test_layout___kernel_fd_set() {
        assert_eq!(
            ::core::mem::size_of::<__kernel_fd_set>(),
            128usize,
            concat!("Size of: ", stringify!(__kernel_fd_set))
        );
        assert_eq!(
            ::core::mem::align_of::<__kernel_fd_set>(),
            8usize,
            concat!("Alignment of ", stringify!(__kernel_fd_set))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__kernel_fd_set),
                "::",
                stringify!(fds_bits)
            )
        );
    }
    pub type __kernel_sighandler_t =
        ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
    pub type __kernel_key_t = libc::c_int;
    pub type __kernel_mqd_t = libc::c_int;
    pub type __kernel_old_uid_t = libc::c_ushort;
    pub type __kernel_old_gid_t = libc::c_ushort;
    pub type __kernel_old_dev_t = libc::c_ulong;
    pub type __kernel_long_t = libc::c_long;
    pub type __kernel_ulong_t = libc::c_ulong;
    pub type __kernel_ino_t = root::__kernel_ulong_t;
    pub type __kernel_mode_t = libc::c_uint;
    pub type __kernel_pid_t = libc::c_int;
    pub type __kernel_ipc_pid_t = libc::c_int;
    pub type __kernel_uid_t = libc::c_uint;
    pub type __kernel_gid_t = libc::c_uint;
    pub type __kernel_suseconds_t = root::__kernel_long_t;
    pub type __kernel_daddr_t = libc::c_int;
    pub type __kernel_uid32_t = libc::c_uint;
    pub type __kernel_gid32_t = libc::c_uint;
    pub type __kernel_size_t = root::__kernel_ulong_t;
    pub type __kernel_ssize_t = root::__kernel_long_t;
    pub type __kernel_ptrdiff_t = root::__kernel_long_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __kernel_fsid_t {
        pub val: [libc::c_int; 2usize],
    }
    #[test]
    fn bindgen_test_layout___kernel_fsid_t() {
        assert_eq!(
            ::core::mem::size_of::<__kernel_fsid_t>(),
            8usize,
            concat!("Size of: ", stringify!(__kernel_fsid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<__kernel_fsid_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__kernel_fsid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__kernel_fsid_t),
                "::",
                stringify!(val)
            )
        );
    }
    pub type __kernel_off_t = root::__kernel_long_t;
    pub type __kernel_loff_t = libc::c_longlong;
    pub type __kernel_time_t = root::__kernel_long_t;
    pub type __kernel_time64_t = libc::c_longlong;
    pub type __kernel_clock_t = root::__kernel_long_t;
    pub type __kernel_timer_t = libc::c_int;
    pub type __kernel_clockid_t = libc::c_int;
    pub type __kernel_caddr_t = *mut libc::c_char;
    pub type __kernel_uid16_t = libc::c_ushort;
    pub type __kernel_gid16_t = libc::c_ushort;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct linger {
        pub l_onoff: libc::c_int,
        pub l_linger: libc::c_int,
    }
    #[test]
    fn bindgen_test_layout_linger() {
        assert_eq!(
            ::core::mem::size_of::<linger>(),
            8usize,
            concat!("Size of: ", stringify!(linger))
        );
        assert_eq!(
            ::core::mem::align_of::<linger>(),
            4usize,
            concat!("Alignment of ", stringify!(linger))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<linger>())).l_onoff as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_onoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<linger>())).l_linger as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_linger)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct osockaddr {
        pub sa_family: libc::c_ushort,
        pub sa_data: [libc::c_uchar; 14usize],
    }
    #[test]
    fn bindgen_test_layout_osockaddr() {
        assert_eq!(
            ::core::mem::size_of::<osockaddr>(),
            16usize,
            concat!("Size of: ", stringify!(osockaddr))
        );
        assert_eq!(
            ::core::mem::align_of::<osockaddr>(),
            2usize,
            concat!("Alignment of ", stringify!(osockaddr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(osockaddr),
                "::",
                stringify!(sa_family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(osockaddr),
                "::",
                stringify!(sa_data)
            )
        );
    }
    pub const SHUT_RD: root::_bindgen_ty_9 = 0;
    pub const SHUT_WR: root::_bindgen_ty_9 = 1;
    pub const SHUT_RDWR: root::_bindgen_ty_9 = 2;
    pub type _bindgen_ty_9 = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mmsghdr {
        pub msg_hdr: root::msghdr,
        pub msg_len: libc::c_uint,
    }
    #[test]
    fn bindgen_test_layout_mmsghdr() {
        assert_eq!(
            ::core::mem::size_of::<mmsghdr>(),
            64usize,
            concat!("Size of: ", stringify!(mmsghdr))
        );
        assert_eq!(
            ::core::mem::align_of::<mmsghdr>(),
            8usize,
            concat!("Alignment of ", stringify!(mmsghdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mmsghdr>())).msg_hdr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmsghdr),
                "::",
                stringify!(msg_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mmsghdr>())).msg_len as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mmsghdr),
                "::",
                stringify!(msg_len)
            )
        );
    }
    extern "C" {
        pub fn socket(
            __domain: libc::c_int,
            __type: libc::c_int,
            __protocol: libc::c_int,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn socketpair(
            __domain: libc::c_int,
            __type: libc::c_int,
            __protocol: libc::c_int,
            __fds: *mut libc::c_int,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn bind(
            __fd: libc::c_int,
            __addr: *const root::sockaddr,
            __len: root::socklen_t,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn getsockname(
            __fd: libc::c_int,
            __addr: *mut root::sockaddr,
            __len: *mut root::socklen_t,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn connect(
            __fd: libc::c_int,
            __addr: *const root::sockaddr,
            __len: root::socklen_t,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn getpeername(
            __fd: libc::c_int,
            __addr: *mut root::sockaddr,
            __len: *mut root::socklen_t,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn send(
            __fd: libc::c_int,
            __buf: *const libc::c_void,
            __n: root::size_t,
            __flags: libc::c_int,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn recv(
            __fd: libc::c_int,
            __buf: *mut libc::c_void,
            __n: root::size_t,
            __flags: libc::c_int,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn sendto(
            __fd: libc::c_int,
            __buf: *const libc::c_void,
            __n: root::size_t,
            __flags: libc::c_int,
            __addr: *const root::sockaddr,
            __addr_len: root::socklen_t,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn recvfrom(
            __fd: libc::c_int,
            __buf: *mut libc::c_void,
            __n: root::size_t,
            __flags: libc::c_int,
            __addr: *mut root::sockaddr,
            __addr_len: *mut root::socklen_t,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn sendmsg(
            __fd: libc::c_int,
            __message: *const root::msghdr,
            __flags: libc::c_int,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn sendmmsg(
            __fd: libc::c_int,
            __vmessages: *mut root::mmsghdr,
            __vlen: libc::c_uint,
            __flags: libc::c_int,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn recvmsg(
            __fd: libc::c_int,
            __message: *mut root::msghdr,
            __flags: libc::c_int,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn recvmmsg(
            __fd: libc::c_int,
            __vmessages: *mut root::mmsghdr,
            __vlen: libc::c_uint,
            __flags: libc::c_int,
            __tmo: *mut root::timespec,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn getsockopt(
            __fd: libc::c_int,
            __level: libc::c_int,
            __optname: libc::c_int,
            __optval: *mut libc::c_void,
            __optlen: *mut root::socklen_t,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn setsockopt(
            __fd: libc::c_int,
            __level: libc::c_int,
            __optname: libc::c_int,
            __optval: *const libc::c_void,
            __optlen: root::socklen_t,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn listen(__fd: libc::c_int, __n: libc::c_int) -> libc::c_int;
    }
    extern "C" {
        pub fn accept(
            __fd: libc::c_int,
            __addr: *mut root::sockaddr,
            __addr_len: *mut root::socklen_t,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn accept4(
            __fd: libc::c_int,
            __addr: *mut root::sockaddr,
            __addr_len: *mut root::socklen_t,
            __flags: libc::c_int,
        ) -> libc::c_int;
    }
    extern "C" {
        pub fn shutdown(__fd: libc::c_int, __how: libc::c_int) -> libc::c_int;
    }
    extern "C" {
        pub fn sockatmark(__fd: libc::c_int) -> libc::c_int;
    }
    extern "C" {
        pub fn isfdtype(__fd: libc::c_int, __fdtype: libc::c_int) -> libc::c_int;
    }
    pub type __int128_t = i128;
    pub type __uint128_t = u128;
}
